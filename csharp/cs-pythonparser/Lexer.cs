// Generated by JavaCC 21 Parser Generator. Do not edit.
// ReSharper disable InconsistentNaming
namespace org.parsers.python {
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    public class Lexer {
        // Lexer fields and properties (non-NFA-related)

        internal static readonly Token DummyStartToken, Ignored, Skipped;

        public string InputSource { get; internal set; }
        private readonly string _content;
        private readonly int _contentLength;


        // The starting line and column, usually 1,1
        // that is used to report a file position 
        // in 1-based line/column terms
        private int startingLine, startingColumn;


        // Token types that are "regular" tokens that participate in parsing,
        // i.e. declared as TOKEN
        private static HashSet<TokenType> regularTokens = Utils.GetOrMakeSet(
            TokenType.EOF,
            TokenType.NEWLINE,
            TokenType.ASSIGN,
            TokenType.AT,
            TokenType.COLON,
            TokenType.COMMA,
            TokenType.EQ,
            TokenType.LBRACE,
            TokenType.RBRACE,
            TokenType.LBRACKET,
            TokenType.RBRACKET,
            TokenType.LPAREN,
            TokenType.RPAREN,
            TokenType.SEMICOLON,
            TokenType.STAR,
            TokenType.STAR_STAR,
            TokenType.MINUSASSIGN,
            TokenType.PLUSASSIGN,
            TokenType.STARASSIGN,
            TokenType.ATASSIGN,
            TokenType.SLASHASSIGN,
            TokenType.REMASSIGN,
            TokenType.ANDASSIGN,
            TokenType.ORASSIGN,
            TokenType.XORASSIGN,
            TokenType.LSHIFTASSIGN,
            TokenType.RSHIFTASSIGN,
            TokenType.STARSTARASSIGN,
            TokenType.SLASHSLASHASSIGN,
            TokenType.BIT_AND,
            TokenType.BIT_OR,
            TokenType.XOR,
            TokenType.TILDE,
            TokenType.COLONEQUALS,
            TokenType.DOT,
            TokenType.ELLIPSIS,
            TokenType.LE,
            TokenType.GE,
            TokenType.NE,
            TokenType.GT,
            TokenType.LT,
            TokenType.MINUS,
            TokenType.PLUS,
            TokenType.SLASH,
            TokenType.PERCENT,
            TokenType.LSHIFT,
            TokenType.RSHIFT,
            TokenType.HOOK,
            TokenType.RARROW,
            TokenType.AND,
            TokenType.AS,
            TokenType._ASSERT,
            TokenType.ASYNC,
            TokenType.AWAIT,
            TokenType.BREAK,
            TokenType.CASE,
            TokenType.CLASS,
            TokenType.CONTINUE,
            TokenType.DEF,
            TokenType.DEL,
            TokenType.EXCEPT,
            TokenType.FINALLY,
            TokenType.FOR,
            TokenType.FROM,
            TokenType.GLOBAL,
            TokenType.IF,
            TokenType.IN,
            TokenType.IS,
            TokenType.ELIF,
            TokenType.ELSE,
            TokenType.FALSE,
            TokenType.IMPORT,
            TokenType.LAMBDA,
            TokenType.MATCH,
            TokenType.NONLOCAL,
            TokenType.NONE,
            TokenType.NOT,
            TokenType.OR,
            TokenType.PASS,
            TokenType.PEG_PARSER,
            TokenType.RAISE,
            TokenType.RETURN,
            TokenType.TRUE,
            TokenType.TRY,
            TokenType.WHILE,
            TokenType.WITH,
            TokenType.YIELD,
            TokenType.DECNUMBER,
            TokenType.BADDECNUMBER,
            TokenType.HEXNUMBER,
            TokenType.OCTNUMBER,
            TokenType.BINNUMBER,
            TokenType.FLOAT,
            TokenType.COMPLEX,
            TokenType.STRING_LITERAL,
            TokenType.NAME,
            TokenType.BADNAME,
            TokenType._TOKEN_100
        );
        // Token types that do not participate in parsing, a.k.a. "special" tokens in legacy JavaCC,
        // i.e. declared as UNPARSED (or SPECIAL_TOKEN)
        private static HashSet<TokenType> unparsedTokens = Utils.GetOrMakeSet(
            TokenType.SPACE,
            TokenType.CONTINUE_LINE,
            TokenType.COMMENT
        );
        private static HashSet<TokenType> skippedTokens = Utils.GetOrMakeSet();
        // Tokens that correspond to a MORE, i.e. that are pending
        // additional input
        private static HashSet<TokenType> moreTokens = Utils.GetOrMakeSet();

        private InvalidToken _invalidToken;
        // internal Token previousToken;


        // NFA code and data

        // The functional interface that represents
        // the acceptance method of an NFA state
        private delegate TokenType? NfaFunction(int ch, BitSet bs, HashSet<TokenType> validTypes);

        private static NfaFunction[] nfaFunctions;

        // Just use the canned binary search to check whether the char
        // is in one of the intervals
        private static bool CheckIntervals(int[] ranges, int ch) {
            var temp = System.Array.BinarySearch(ranges, ch);
            return temp >=0 || temp % 2 == 0;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_0(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '\f') {
                nextStates.Set(19);
            }
            if (ch == ' ') {
                nextStates.Set(19);
            }
            if (ch == '!') {
                nextStates.Set(249);
            }
            if (ch == '"') {
                nextStates.Set(148);
                nextStates.Set(74);
            }
            if (ch == '%') {
                nextStates.Set(275);
            }
            if (ch == '&') {
                nextStates.Set(123);
            }
            if (ch == '\'') {
                nextStates.Set(264);
                nextStates.Set(68);
            }
            if (ch == '*') {
                nextStates.Set(174);
                nextStates.Set(196);
                nextStates.Set(290);
            }
            if (ch == '+') {
                nextStates.Set(173);
            }
            if (ch == '-') {
                nextStates.Set(397);
                nextStates.Set(169);
            }
            if (ch == '.') {
                nextStates.Set(414);
                nextStates.Set(254);
                nextStates.Set(461);
            }
            if (ch == '/') {
                nextStates.Set(208);
                nextStates.Set(378);
                nextStates.Set(359);
            }
            if (ch == '0') {
                nextStates.Set(403);
                nextStates.Set(44);
                nextStates.Set(33);
                nextStates.Set(271);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(61);
                nextStates.Set(62);
                nextStates.Set(89);
                nextStates.Set(73);
                nextStates.Set(29);
            }
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(63);
            }
            if (ch == ':') {
                nextStates.Set(138);
            }
            if (ch == '<') {
                nextStates.Set(438);
                nextStates.Set(147);
                nextStates.Set(448);
            }
            if (ch == '=') {
                nextStates.Set(158);
            }
            if (ch == '>') {
                nextStates.Set(108);
                nextStates.Set(190);
                nextStates.Set(177);
            }
            if (ch == '?') {
                nextStates.Set(288);
            }
            if (ch == '@') {
                nextStates.Set(105);
            }
            if (ch == 'B') {
                nextStates.Set(189);
                nextStates.Set(191);
                nextStates.Set(328);
                nextStates.Set(187);
                nextStates.Set(434);
                nextStates.Set(141);
                nextStates.Set(390);
                nextStates.Set(119);
                nextStates.Set(222);
                nextStates.Set(188);
                nextStates.Set(270);
                nextStates.Set(349);
            }
            if (ch == 'F') {
                nextStates.Set(331);
                nextStates.Set(200);
                nextStates.Set(458);
                nextStates.Set(262);
                nextStates.Set(416);
                nextStates.Set(156);
                nextStates.Set(375);
                nextStates.Set(657);
                nextStates.Set(640);
                nextStates.Set(544);
                nextStates.Set(373);
                nextStates.Set(137);
                nextStates.Set(491);
            }
            if (ch == 'N') {
                nextStates.Set(235);
            }
            if (ch == 'R') {
                nextStates.Set(451);
                nextStates.Set(431);
                nextStates.Set(103);
                nextStates.Set(491);
                nextStates.Set(180);
                nextStates.Set(164);
                nextStates.Set(223);
                nextStates.Set(255);
                nextStates.Set(396);
                nextStates.Set(386);
                nextStates.Set(107);
                nextStates.Set(239);
                nextStates.Set(640);
                nextStates.Set(421);
                nextStates.Set(453);
                nextStates.Set(342);
                nextStates.Set(457);
                nextStates.Set(657);
                nextStates.Set(439);
                nextStates.Set(544);
            }
            if (ch == 'T') {
                nextStates.Set(192);
            }
            if (ch == 'U') {
                nextStates.Set(657);
                nextStates.Set(491);
                nextStates.Set(544);
                nextStates.Set(640);
            }
            if (ch == '\\') {
                nextStates.Set(214);
            }
            if (ch == '^') {
                nextStates.Set(295);
            }
            if (ch == '_') {
                nextStates.Set(407);
            }
            if (ch == 'a') {
                nextStates.Set(113);
                nextStates.Set(455);
                nextStates.Set(221);
                nextStates.Set(368);
                nextStates.Set(419);
            }
            if (ch == 'b') {
                nextStates.Set(277);
                nextStates.Set(265);
                nextStates.Set(189);
                nextStates.Set(191);
                nextStates.Set(104);
                nextStates.Set(211);
                nextStates.Set(258);
                nextStates.Set(270);
                nextStates.Set(402);
                nextStates.Set(283);
                nextStates.Set(321);
                nextStates.Set(227);
                nextStates.Set(119);
            }
            if (ch == 'c') {
                nextStates.Set(338);
                nextStates.Set(436);
                nextStates.Set(392);
            }
            if (ch == 'd') {
                nextStates.Set(425);
                nextStates.Set(153);
            }
            if (ch == 'e') {
                nextStates.Set(242);
                nextStates.Set(269);
                nextStates.Set(186);
            }
            if (ch == 'f') {
                nextStates.Set(657);
                nextStates.Set(170);
                nextStates.Set(452);
                nextStates.Set(424);
                nextStates.Set(640);
                nextStates.Set(274);
                nextStates.Set(251);
                nextStates.Set(325);
                nextStates.Set(544);
                nextStates.Set(335);
                nextStates.Set(182);
                nextStates.Set(308);
                nextStates.Set(491);
                nextStates.Set(322);
                nextStates.Set(422);
            }
            if (ch == 'g') {
                nextStates.Set(228);
            }
            if (ch == 'i') {
                nextStates.Set(151);
                nextStates.Set(131);
                nextStates.Set(429);
                nextStates.Set(225);
            }
            if (ch == 'l') {
                nextStates.Set(298);
            }
            if (ch == 'm') {
                nextStates.Set(413);
            }
            if (ch == 'n') {
                nextStates.Set(110);
                nextStates.Set(365);
            }
            if (ch == 'o') {
                nextStates.Set(252);
            }
            if (ch == 'p') {
                nextStates.Set(319);
            }
            if (ch == 'r') {
                nextStates.Set(149);
                nextStates.Set(310);
                nextStates.Set(116);
                nextStates.Set(408);
                nextStates.Set(544);
                nextStates.Set(406);
                nextStates.Set(171);
                nextStates.Set(456);
                nextStates.Set(423);
                nextStates.Set(233);
                nextStates.Set(162);
                nextStates.Set(491);
                nextStates.Set(657);
                nextStates.Set(296);
                nextStates.Set(363);
                nextStates.Set(102);
                nextStates.Set(216);
                nextStates.Set(179);
                nextStates.Set(337);
                nextStates.Set(640);
                nextStates.Set(445);
                nextStates.Set(139);
            }
            if (ch == 't') {
                nextStates.Set(357);
            }
            if (ch == 'u') {
                nextStates.Set(491);
                nextStates.Set(657);
                nextStates.Set(640);
                nextStates.Set(544);
            }
            if (ch == 'w') {
                nextStates.Set(318);
                nextStates.Set(109);
            }
            if (ch == 'y') {
                nextStates.Set(340);
            }
            if (ch == '|') {
                nextStates.Set(205);
            }
            if ((ch >= 'A' && ch <= 'Z' ) || ((ch == '_') || ((ch >= 'a' && ch <= 'z' ) || (ch >= 0x80 && ch <= 0xffff )))) {
                nextStates.Set(329);
                if (validTypes.Contains(TokenType.BADNAME)) {
                    type = TokenType.BADNAME;
                }
            }
            if (((ch >= 'A' && ch <= 'Z' ) || ((ch == '_') || (ch >= 'a' && ch <= 'z' ))) || ((ch >= (char) 128) && CheckIntervals(NFA_MOVES_PYTHON_111, ch))) {
                nextStates.Set(224);
                if (validTypes.Contains(TokenType.NAME)) {
                    type = TokenType.NAME;
                }
            }
            if (ch == '0') {
                nextStates.Set(8);
                nextStates.Set(482);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    type = TokenType.DECNUMBER;
                }
            }
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(31);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    type = TokenType.DECNUMBER;
                }
            }
            if (ch == '%') {
                if (validTypes.Contains(TokenType.PERCENT)) {
                    type = TokenType.PERCENT;
                }
            }
            if (ch == '/') {
                if (validTypes.Contains(TokenType.SLASH)) {
                    type = TokenType.SLASH;
                }
            }
            if (ch == '+') {
                if (validTypes.Contains(TokenType.PLUS)) {
                    type = TokenType.PLUS;
                }
            }
            if (ch == '-') {
                if (validTypes.Contains(TokenType.MINUS)) {
                    type = TokenType.MINUS;
                }
            }
            if (ch == '<') {
                if (validTypes.Contains(TokenType.LT)) {
                    type = TokenType.LT;
                }
            }
            if (ch == '>') {
                if (validTypes.Contains(TokenType.GT)) {
                    type = TokenType.GT;
                }
            }
            if (ch == '.') {
                if (validTypes.Contains(TokenType.DOT)) {
                    type = TokenType.DOT;
                }
            }
            if (ch == '~') {
                if (validTypes.Contains(TokenType.TILDE)) {
                    type = TokenType.TILDE;
                }
            }
            if (ch == '^') {
                if (validTypes.Contains(TokenType.XOR)) {
                    type = TokenType.XOR;
                }
            }
            if (ch == '|') {
                if (validTypes.Contains(TokenType.BIT_OR)) {
                    type = TokenType.BIT_OR;
                }
            }
            if (ch == '&') {
                if (validTypes.Contains(TokenType.BIT_AND)) {
                    type = TokenType.BIT_AND;
                }
            }
            if (ch == '*') {
                if (validTypes.Contains(TokenType.STAR)) {
                    type = TokenType.STAR;
                }
            }
            if (ch == ';') {
                if (validTypes.Contains(TokenType.SEMICOLON)) {
                    type = TokenType.SEMICOLON;
                }
            }
            if (ch == ')') {
                if (validTypes.Contains(TokenType.RPAREN)) {
                    type = TokenType.RPAREN;
                }
            }
            if (ch == '(') {
                if (validTypes.Contains(TokenType.LPAREN)) {
                    type = TokenType.LPAREN;
                }
            }
            if (ch == ']') {
                if (validTypes.Contains(TokenType.RBRACKET)) {
                    type = TokenType.RBRACKET;
                }
            }
            if (ch == '[') {
                if (validTypes.Contains(TokenType.LBRACKET)) {
                    type = TokenType.LBRACKET;
                }
            }
            if (ch == '}') {
                if (validTypes.Contains(TokenType.RBRACE)) {
                    type = TokenType.RBRACE;
                }
            }
            if (ch == '{') {
                if (validTypes.Contains(TokenType.LBRACE)) {
                    type = TokenType.LBRACE;
                }
            }
            if (ch == ',') {
                if (validTypes.Contains(TokenType.COMMA)) {
                    type = TokenType.COMMA;
                }
            }
            if (ch == ':') {
                if (validTypes.Contains(TokenType.COLON)) {
                    type = TokenType.COLON;
                }
            }
            if (ch == '@') {
                if (validTypes.Contains(TokenType.AT)) {
                    type = TokenType.AT;
                }
            }
            if (ch == '=') {
                if (validTypes.Contains(TokenType.ASSIGN)) {
                    type = TokenType.ASSIGN;
                }
            }
            if (ch == '\n') {
                if (validTypes.Contains(TokenType.NEWLINE)) {
                    type = TokenType.NEWLINE;
                }
            }
            if (ch == '#') {
                nextStates.Set(415);
                if (validTypes.Contains(TokenType.COMMENT)) {
                    type = TokenType.COMMENT;
                }
            }
            if (ch == '\f') {
                nextStates.Set(49);
                if (validTypes.Contains(TokenType.SPACE)) {
                    type = TokenType.SPACE;
                }
            }
            if (ch == ' ') {
                nextStates.Set(49);
                if (validTypes.Contains(TokenType.SPACE)) {
                    type = TokenType.SPACE;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_1(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(549);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(1);
                if (validTypes.Contains(TokenType.BADDECNUMBER)) {
                    type = TokenType.BADDECNUMBER;
                }
            }
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.BADDECNUMBER)) {
                    type = TokenType.BADDECNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_2(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(37);
            }
            if (ch == '\\') {
                nextStates.Set(343);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_3(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(59);
            }
            if (ch == '\\') {
                nextStates.Set(133);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_4(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '!' ) || ((ch >= '#' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(74);
            }
            if (ch == '\\') {
                nextStates.Set(447);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_5(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(45);
            }
            if (ch == '_') {
                nextStates.Set(650);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_6(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(61);
            }
            if (ch == '_') {
                nextStates.Set(570);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_7(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(636);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(31);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    type = TokenType.DECNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_8(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(536);
            }
            if (ch == '0' || ch == '1') {
                nextStates.Set(28);
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    type = TokenType.BINNUMBER;
                }
            }
            if ((ch == 'B') || (ch == 'b')) {
                nextStates.Set(28);
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    type = TokenType.BINNUMBER;
                }
            }
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    type = TokenType.BINNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_9(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(658);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(18);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_10(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '.') {
                nextStates.Set(254);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(62);
                nextStates.Set(61);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_11(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'B') {
                nextStates.Set(390);
                nextStates.Set(191);
                nextStates.Set(349);
            }
            if (ch == 'R') {
                nextStates.Set(386);
                nextStates.Set(103);
            }
            if (ch == 'b') {
                nextStates.Set(277);
                nextStates.Set(191);
                nextStates.Set(104);
            }
            if (ch == 'r') {
                nextStates.Set(456);
                nextStates.Set(363);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_12(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '"') {
                nextStates.Set(74);
            }
            if (ch == 'F') {
                nextStates.Set(137);
                nextStates.Set(640);
                nextStates.Set(373);
            }
            if (ch == 'R') {
                nextStates.Set(239);
                nextStates.Set(640);
                nextStates.Set(255);
            }
            if (ch == 'U') {
                nextStates.Set(640);
            }
            if (ch == 'f') {
                nextStates.Set(335);
                nextStates.Set(640);
                nextStates.Set(170);
            }
            if (ch == 'r') {
                nextStates.Set(102);
                nextStates.Set(640);
                nextStates.Set(139);
            }
            if (ch == 'u') {
                nextStates.Set(640);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_13(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(97);
            }
            if (ch == '"') {
                nextStates.Set(94);
            }
            if (ch == '\\') {
                nextStates.Set(291);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_14(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '"') {
                nextStates.Set(148);
            }
            if (ch == 'F') {
                nextStates.Set(416);
                nextStates.Set(544);
                nextStates.Set(458);
            }
            if (ch == 'R') {
                nextStates.Set(421);
                nextStates.Set(457);
                nextStates.Set(544);
            }
            if (ch == 'U') {
                nextStates.Set(544);
            }
            if (ch == 'f') {
                nextStates.Set(424);
                nextStates.Set(544);
                nextStates.Set(274);
            }
            if (ch == 'r') {
                nextStates.Set(544);
                nextStates.Set(445);
                nextStates.Set(406);
            }
            if (ch == 'u') {
                nextStates.Set(544);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_15(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(47);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_16(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(37);
            }
            if (ch == '\'') {
                nextStates.Set(81);
            }
            if (ch == '\\') {
                nextStates.Set(343);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_17(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(62);
            }
            if (ch == '_') {
                nextStates.Set(560);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_18(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(42);
            }
            if (ch == '_') {
                nextStates.Set(658);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(18);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_19(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '\f') {
                nextStates.Set(19);
            }
            if (ch == ' ') {
                nextStates.Set(19);
            }
            if (ch == '\n') {
                if (validTypes.Contains(TokenType.NEWLINE)) {
                    type = TokenType.NEWLINE;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_20(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == 'L') || (ch == 'l')) {
                nextStates.Set(475);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_21(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '.') {
                nextStates.Set(254);
            }
            if (ch == '0') {
                nextStates.Set(44);
                nextStates.Set(33);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(62);
                nextStates.Set(61);
            }
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(63);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_22(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(22);
            }
            if (ch == '_') {
                nextStates.Set(590);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_23(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(89);
            }
            if (ch == '_') {
                nextStates.Set(507);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_24(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(24);
            }
            if (ch == '\'') {
                nextStates.Set(198);
                nextStates.Set(55);
            }
            if (ch == '\\') {
                nextStates.Set(297);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_25(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(22);
            }
            if (ch == '_') {
                nextStates.Set(590);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_26(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(40);
            }
            if (ch == '_') {
                nextStates.Set(478);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_27(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'B') {
                nextStates.Set(434);
                nextStates.Set(188);
                nextStates.Set(119);
            }
            if (ch == 'R') {
                nextStates.Set(431);
                nextStates.Set(396);
            }
            if (ch == 'b') {
                nextStates.Set(258);
                nextStates.Set(227);
                nextStates.Set(119);
            }
            if (ch == 'r') {
                nextStates.Set(408);
                nextStates.Set(162);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_28(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(536);
            }
            if (ch == '0' || ch == '1') {
                nextStates.Set(28);
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    type = TokenType.BINNUMBER;
                }
            }
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    type = TokenType.BINNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_29(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(549);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(1);
                if (validTypes.Contains(TokenType.BADDECNUMBER)) {
                    type = TokenType.BADDECNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_30(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(646);
            }
            if ((ch >= '0' && ch <= '9' ) || ((ch >= 'A' && ch <= 'F' ) || (ch >= 'a' && ch <= 'f' ))) {
                nextStates.Set(80);
                if (validTypes.Contains(TokenType.HEXNUMBER)) {
                    type = TokenType.HEXNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_31(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(636);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(31);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    type = TokenType.DECNUMBER;
                }
            }
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    type = TokenType.DECNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_32(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '\f') {
                nextStates.Set(19);
            }
            if (ch == ' ') {
                nextStates.Set(19);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_33(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '0') {
                nextStates.Set(33);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_34(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '\'') {
                nextStates.Set(68);
            }
            if (ch == 'F') {
                nextStates.Set(262);
                nextStates.Set(657);
                nextStates.Set(331);
            }
            if (ch == 'R') {
                nextStates.Set(451);
                nextStates.Set(657);
                nextStates.Set(342);
            }
            if (ch == 'U') {
                nextStates.Set(657);
            }
            if (ch == 'f') {
                nextStates.Set(657);
                nextStates.Set(251);
                nextStates.Set(452);
            }
            if (ch == 'r') {
                nextStates.Set(423);
                nextStates.Set(657);
                nextStates.Set(337);
            }
            if (ch == 'u') {
                nextStates.Set(657);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_35(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(495);
            }
            if (ch >= '0' && ch <= '7' ) {
                nextStates.Set(65);
                if (validTypes.Contains(TokenType.OCTNUMBER)) {
                    type = TokenType.OCTNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_36(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '&' ) || ((ch >= '(' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(68);
            }
            if (ch == '\\') {
                nextStates.Set(354);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_37(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(37);
            }
            if (ch == '\'') {
                nextStates.Set(81);
                nextStates.Set(400);
            }
            if (ch == '\\') {
                nextStates.Set(343);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_38(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(24);
            }
            if (ch == '\'') {
                nextStates.Set(55);
            }
            if (ch == '\\') {
                nextStates.Set(297);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_39(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(498);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(96);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_40(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(40);
            }
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(47);
            }
            if (ch == '_') {
                nextStates.Set(478);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_41(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '0') {
                nextStates.Set(33);
            }
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(63);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_42(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(662);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(83);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_43(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(59);
            }
            if (ch == '"') {
                nextStates.Set(51);
            }
            if (ch == '\\') {
                nextStates.Set(133);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_44(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '0') {
                nextStates.Set(90);
            }
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(54);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_45(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(45);
            }
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(92);
            }
            if (ch == '_') {
                nextStates.Set(650);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_46(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(76);
            }
            if (ch == '_') {
                nextStates.Set(599);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_47(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(663);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(22);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_48(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(82);
            }
            if (ch == '_') {
                nextStates.Set(476);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(48);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_49(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '\f') {
                nextStates.Set(49);
                if (validTypes.Contains(TokenType.SPACE)) {
                    type = TokenType.SPACE;
                }
            }
            if (ch == ' ') {
                nextStates.Set(49);
                if (validTypes.Contains(TokenType.SPACE)) {
                    type = TokenType.SPACE;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_50(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '\'') {
                nextStates.Set(264);
            }
            if (ch == 'F') {
                nextStates.Set(156);
                nextStates.Set(375);
                nextStates.Set(491);
            }
            if (ch == 'R') {
                nextStates.Set(107);
                nextStates.Set(453);
                nextStates.Set(491);
            }
            if (ch == 'U') {
                nextStates.Set(491);
            }
            if (ch == 'f') {
                nextStates.Set(491);
                nextStates.Set(322);
                nextStates.Set(422);
            }
            if (ch == 'r') {
                nextStates.Set(233);
                nextStates.Set(310);
                nextStates.Set(491);
            }
            if (ch == 'u') {
                nextStates.Set(491);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_51(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(59);
            }
            if (ch == '"') {
                nextStates.Set(3);
            }
            if (ch == '\\') {
                nextStates.Set(133);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_52(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(92);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_53(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(97);
            }
            if (ch == '\\') {
                nextStates.Set(291);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_54(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(54);
            }
            if ((ch == 'L') || (ch == 'l')) {
                nextStates.Set(475);
            }
            if (ch == '_') {
                nextStates.Set(519);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_55(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(24);
            }
            if (ch == '\'') {
                nextStates.Set(57);
            }
            if (ch == '\\') {
                nextStates.Set(297);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_56(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '"') {
                nextStates.Set(74);
                nextStates.Set(148);
            }
            if (ch == '\'') {
                nextStates.Set(264);
                nextStates.Set(68);
            }
            if (ch == 'B') {
                nextStates.Set(189);
                nextStates.Set(191);
                nextStates.Set(328);
                nextStates.Set(187);
                nextStates.Set(434);
                nextStates.Set(222);
                nextStates.Set(141);
                nextStates.Set(188);
                nextStates.Set(390);
                nextStates.Set(270);
                nextStates.Set(119);
                nextStates.Set(349);
            }
            if (ch == 'F') {
                nextStates.Set(375);
                nextStates.Set(657);
                nextStates.Set(331);
                nextStates.Set(640);
                nextStates.Set(544);
                nextStates.Set(373);
                nextStates.Set(137);
                nextStates.Set(458);
                nextStates.Set(262);
                nextStates.Set(491);
                nextStates.Set(416);
                nextStates.Set(156);
            }
            if (ch == 'R') {
                nextStates.Set(239);
                nextStates.Set(451);
                nextStates.Set(431);
                nextStates.Set(103);
                nextStates.Set(640);
                nextStates.Set(421);
                nextStates.Set(453);
                nextStates.Set(491);
                nextStates.Set(180);
                nextStates.Set(342);
                nextStates.Set(457);
                nextStates.Set(164);
                nextStates.Set(223);
                nextStates.Set(657);
                nextStates.Set(255);
                nextStates.Set(396);
                nextStates.Set(439);
                nextStates.Set(386);
                nextStates.Set(107);
                nextStates.Set(544);
            }
            if (ch == 'U') {
                nextStates.Set(491);
                nextStates.Set(544);
                nextStates.Set(657);
                nextStates.Set(640);
            }
            if (ch == 'b') {
                nextStates.Set(277);
                nextStates.Set(265);
                nextStates.Set(402);
                nextStates.Set(283);
                nextStates.Set(189);
                nextStates.Set(321);
                nextStates.Set(191);
                nextStates.Set(104);
                nextStates.Set(227);
                nextStates.Set(258);
                nextStates.Set(270);
                nextStates.Set(119);
            }
            if (ch == 'f') {
                nextStates.Set(657);
                nextStates.Set(170);
                nextStates.Set(452);
                nextStates.Set(424);
                nextStates.Set(544);
                nextStates.Set(335);
                nextStates.Set(640);
                nextStates.Set(491);
                nextStates.Set(274);
                nextStates.Set(251);
                nextStates.Set(322);
                nextStates.Set(422);
            }
            if (ch == 'r') {
                nextStates.Set(296);
                nextStates.Set(363);
                nextStates.Set(102);
                nextStates.Set(149);
                nextStates.Set(310);
                nextStates.Set(337);
                nextStates.Set(116);
                nextStates.Set(408);
                nextStates.Set(544);
                nextStates.Set(406);
                nextStates.Set(171);
                nextStates.Set(456);
                nextStates.Set(423);
                nextStates.Set(233);
                nextStates.Set(162);
                nextStates.Set(491);
                nextStates.Set(640);
                nextStates.Set(657);
                nextStates.Set(445);
                nextStates.Set(139);
            }
            if (ch == 'u') {
                nextStates.Set(491);
                nextStates.Set(657);
                nextStates.Set(640);
                nextStates.Set(544);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_57(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(24);
            }
            if (ch == '\\') {
                nextStates.Set(297);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_58(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(73);
            }
            if (ch == '_') {
                nextStates.Set(595);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_59(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(59);
            }
            if (ch == '"') {
                nextStates.Set(51);
                nextStates.Set(306);
            }
            if (ch == '\\') {
                nextStates.Set(133);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_60(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(476);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(48);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_61(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(61);
            }
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(39);
            }
            if (ch == '_') {
                nextStates.Set(570);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_62(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '.') {
                nextStates.Set(45);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(62);
            }
            if (ch == '_') {
                nextStates.Set(560);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_63(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(63);
            }
            if ((ch == 'L') || (ch == 'l')) {
                nextStates.Set(475);
            }
            if (ch == '_') {
                nextStates.Set(634);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_64(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'F') {
                nextStates.Set(262);
                nextStates.Set(657);
                nextStates.Set(331);
            }
            if (ch == 'R') {
                nextStates.Set(451);
                nextStates.Set(657);
                nextStates.Set(342);
            }
            if (ch == 'U') {
                nextStates.Set(657);
            }
            if (ch == 'f') {
                nextStates.Set(657);
                nextStates.Set(251);
                nextStates.Set(452);
            }
            if (ch == 'r') {
                nextStates.Set(423);
                nextStates.Set(657);
                nextStates.Set(337);
            }
            if (ch == 'u') {
                nextStates.Set(657);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_65(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(495);
            }
            if (ch >= '0' && ch <= '7' ) {
                nextStates.Set(65);
                if (validTypes.Contains(TokenType.OCTNUMBER)) {
                    type = TokenType.OCTNUMBER;
                }
            }
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.OCTNUMBER)) {
                    type = TokenType.OCTNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_66(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '!' ) || ((ch >= '#' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(67);
            }
            if (ch == '\\') {
                nextStates.Set(444);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_67(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '!' ) || ((ch >= '#' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(67);
            }
            if (ch == '\\') {
                nextStates.Set(444);
            }
            if (ch == '"') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    type = TokenType.STRING_LITERAL;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_68(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '&' ) || ((ch >= '(' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(68);
            }
            if (ch == '\\') {
                nextStates.Set(354);
            }
            if (ch == '\'') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    type = TokenType.STRING_LITERAL;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_69(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'F') {
                nextStates.Set(137);
                nextStates.Set(640);
                nextStates.Set(373);
            }
            if (ch == 'R') {
                nextStates.Set(239);
                nextStates.Set(640);
                nextStates.Set(255);
            }
            if (ch == 'U') {
                nextStates.Set(640);
            }
            if (ch == 'f') {
                nextStates.Set(335);
                nextStates.Set(640);
                nextStates.Set(170);
            }
            if (ch == 'r') {
                nextStates.Set(102);
                nextStates.Set(640);
                nextStates.Set(139);
            }
            if (ch == 'u') {
                nextStates.Set(640);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_70(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(666);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(70);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_71(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'F') {
                nextStates.Set(416);
                nextStates.Set(544);
                nextStates.Set(458);
            }
            if (ch == 'R') {
                nextStates.Set(421);
                nextStates.Set(457);
                nextStates.Set(544);
            }
            if (ch == 'U') {
                nextStates.Set(544);
            }
            if (ch == 'f') {
                nextStates.Set(424);
                nextStates.Set(544);
                nextStates.Set(274);
            }
            if (ch == 'r') {
                nextStates.Set(544);
                nextStates.Set(445);
                nextStates.Set(406);
            }
            if (ch == 'u') {
                nextStates.Set(544);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_72(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'B') {
                nextStates.Set(141);
                nextStates.Set(270);
                nextStates.Set(187);
            }
            if (ch == 'R') {
                nextStates.Set(223);
                nextStates.Set(164);
            }
            if (ch == 'b') {
                nextStates.Set(402);
                nextStates.Set(283);
                nextStates.Set(270);
            }
            if (ch == 'r') {
                nextStates.Set(171);
                nextStates.Set(116);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_73(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(73);
            }
            if (ch == '_') {
                nextStates.Set(595);
            }
            if (ch == '.') {
                nextStates.Set(48);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_74(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '!' ) || ((ch >= '#' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(74);
            }
            if (ch == '\\') {
                nextStates.Set(447);
            }
            if (ch == '"') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    type = TokenType.STRING_LITERAL;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_75(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(474);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(70);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_76(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(76);
            }
            if (ch == '_') {
                nextStates.Set(599);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_77(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '&' ) || ((ch >= '(' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(77);
            }
            if (ch == '\\') {
                nextStates.Set(372);
            }
            if (ch == '\'') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    type = TokenType.STRING_LITERAL;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_78(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'B') {
                nextStates.Set(222);
                nextStates.Set(328);
                nextStates.Set(189);
            }
            if (ch == 'R') {
                nextStates.Set(180);
                nextStates.Set(439);
            }
            if (ch == 'b') {
                nextStates.Set(265);
                nextStates.Set(189);
                nextStates.Set(321);
            }
            if (ch == 'r') {
                nextStates.Set(296);
                nextStates.Set(149);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_79(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(536);
            }
            if (ch == '0' || ch == '1') {
                nextStates.Set(28);
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    type = TokenType.BINNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_80(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(646);
            }
            if ((ch >= '0' && ch <= '9' ) || ((ch >= 'A' && ch <= 'F' ) || (ch >= 'a' && ch <= 'f' ))) {
                nextStates.Set(80);
                if (validTypes.Contains(TokenType.HEXNUMBER)) {
                    type = TokenType.HEXNUMBER;
                }
            }
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.HEXNUMBER)) {
                    type = TokenType.HEXNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_81(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(37);
            }
            if (ch == '\'') {
                nextStates.Set(2);
            }
            if (ch == '\\') {
                nextStates.Set(343);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_82(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(581);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(88);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_83(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(580);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(83);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_84(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(63);
            }
            if (ch == '_') {
                nextStates.Set(634);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_85(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(54);
            }
            if (ch == '_') {
                nextStates.Set(519);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_86(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(96);
            }
            if (ch == '_') {
                nextStates.Set(568);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_87(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '.') {
                nextStates.Set(461);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(89);
                nextStates.Set(73);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_88(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '_') {
                nextStates.Set(648);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(88);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    type = TokenType.FLOAT;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_89(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(89);
            }
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(75);
            }
            if (ch == '_') {
                nextStates.Set(507);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_90(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '0') {
                nextStates.Set(90);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_91(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '&' ) || ((ch >= '(' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(77);
            }
            if (ch == '\\') {
                nextStates.Set(372);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_92(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(683);
            }
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(76);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_93(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == '0') {
                nextStates.Set(482);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    type = TokenType.DECNUMBER;
                }
            }
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(31);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    type = TokenType.DECNUMBER;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_94(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(97);
            }
            if (ch == '"') {
                nextStates.Set(53);
            }
            if (ch == '\\') {
                nextStates.Set(291);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_95(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch == 'F') {
                nextStates.Set(156);
                nextStates.Set(375);
                nextStates.Set(491);
            }
            if (ch == 'R') {
                nextStates.Set(107);
                nextStates.Set(453);
                nextStates.Set(491);
            }
            if (ch == 'U') {
                nextStates.Set(491);
            }
            if (ch == 'f') {
                nextStates.Set(491);
                nextStates.Set(322);
                nextStates.Set(422);
            }
            if (ch == 'r') {
                nextStates.Set(233);
                nextStates.Set(310);
                nextStates.Set(491);
            }
            if (ch == 'u') {
                nextStates.Set(491);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_96(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(96);
            }
            if (ch == '_') {
                nextStates.Set(568);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_97(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(97);
            }
            if (ch == '"') {
                nextStates.Set(243);
                nextStates.Set(94);
            }
            if (ch == '\\') {
                nextStates.Set(291);
            }
            return type;
        }

        static TokenType? NFA_COMPOSITE_PYTHON_98(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            TokenType? type = null;
            if ((ch == 'L') || (ch == 'l')) {
                nextStates.Set(475);
            }
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    type = TokenType.COMPLEX;
                }
            }
            return type;
        }

        private static TokenType? NFA_PYTHON_99(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '%') {
                if (validTypes.Contains(TokenType.PERCENT)) {
                    return TokenType.PERCENT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_100(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '>') {
                if (validTypes.Contains(TokenType.GT)) {
                    return TokenType.GT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_101(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.Set(414);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_102(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_103(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_104(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_105(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.ATASSIGN)) {
                    return TokenType.ATASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_106(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'g') {
                nextStates.Set(228);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_107(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_108(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.GE)) {
                    return TokenType.GE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_109(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'h') {
                nextStates.Set(307);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_110(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(136);
            }
            return null;
        }

        private static int[] NFA_MOVES_PYTHON_111 = {
            'A',
            'Z',
            '_',
            '_',
            'a',
            'z',
            0xaa,
            0xaa,
            0xb5,
            0xb5,
            0xba,
            0xba,
            0xc0,
            0xd6,
            0xd8,
            0xf6,
            0xf8,
            0x13e,
            0x141,
            0x2c1,
            0x2c6,
            0x2d1,
            0x2e0,
            0x2e4,
            0x2ec,
            0x2ec,
            0x2ee,
            0x2ee,
            0x370,
            0x374,
            0x376,
            0x377,
            0x37b,
            0x37d,
            0x37f,
            0x37f,
            0x386,
            0x386,
            0x388,
            0x38a,
            0x38c,
            0x38c,
            0x38e,
            0x3a1,
            0x3a3,
            0x3f5,
            0x3f7,
            0x481,
            0x48a,
            0x52f,
            0x531,
            0x556,
            0x559,
            0x559,
            0x560,
            0x588,
            0x5d0,
            0x5ea,
            0x5ef,
            0x5f2,
            0x620,
            0x64a,
            0x66e,
            0x66f,
            0x671,
            0x6d3,
            0x6d5,
            0x6d5,
            0x6e5,
            0x6e6,
            0x6ee,
            0x6ef,
            0x6fa,
            0x6fc,
            0x6ff,
            0x6ff,
            0x710,
            0x710,
            0x712,
            0x72f,
            0x74d,
            0x7a5,
            0x7b1,
            0x7b1,
            0x7ca,
            0x7ea,
            0x7f4,
            0x7f5,
            0x7fa,
            0x7fa,
            0x800,
            0x815,
            0x81a,
            0x81a,
            0x824,
            0x824,
            0x828,
            0x828,
            0x840,
            0x858,
            0x860,
            0x86a,
            0x8a0,
            0x8b4,
            0x8b6,
            0x8c7,
            0x904,
            0x939,
            0x93d,
            0x93d,
            0x950,
            0x950,
            0x958,
            0x961,
            0x971,
            0x980,
            0x985,
            0x98c,
            0x98f,
            0x990,
            0x993,
            0x9a8,
            0x9aa,
            0x9b0,
            0x9b2,
            0x9b2,
            0x9b6,
            0x9b9,
            0x9bd,
            0x9bd,
            0x9ce,
            0x9ce,
            0x9dc,
            0x9dd,
            0x9df,
            0x9e1,
            0x9f0,
            0x9f1,
            0x9fc,
            0x9fc,
            0xa05,
            0xa0a,
            0xa0f,
            0xa10,
            0xa13,
            0xa28,
            0xa2a,
            0xa30,
            0xa32,
            0xa33,
            0xa35,
            0xa36,
            0xa38,
            0xa39,
            0xa59,
            0xa5c,
            0xa5e,
            0xa5e,
            0xa72,
            0xa74,
            0xa85,
            0xa8d,
            0xa8f,
            0xa91,
            0xa93,
            0xaa8,
            0xaaa,
            0xab0,
            0xab2,
            0xab3,
            0xab5,
            0xab9,
            0xabd,
            0xabd,
            0xad0,
            0xad0,
            0xae0,
            0xae1,
            0xaf9,
            0xaf9,
            0xb05,
            0xb0c,
            0xb0f,
            0xb10,
            0xb13,
            0xb28,
            0xb2a,
            0xb30,
            0xb32,
            0xb33,
            0xb35,
            0xb39,
            0xb3d,
            0xb3d,
            0xb5c,
            0xb5d,
            0xb5f,
            0xb61,
            0xb71,
            0xb71,
            0xb83,
            0xb83,
            0xb85,
            0xb8a,
            0xb8e,
            0xb90,
            0xb92,
            0xb95,
            0xb99,
            0xb9a,
            0xb9c,
            0xb9c,
            0xb9e,
            0xb9f,
            0xba3,
            0xba4,
            0xba8,
            0xbaa,
            0xbae,
            0xbb9,
            0xbd0,
            0xbd0,
            0xc05,
            0xc0c,
            0xc0e,
            0xc10,
            0xc12,
            0xc28,
            0xc2a,
            0xc39,
            0xc3d,
            0xc3d,
            0xc58,
            0xc5a,
            0xc60,
            0xc61,
            0xc80,
            0xc80,
            0xc85,
            0xc8c,
            0xc8e,
            0xc90,
            0xc92,
            0xca8,
            0xcaa,
            0xcb3,
            0xcb5,
            0xcb9,
            0xcbd,
            0xcbd,
            0xcde,
            0xcde,
            0xce0,
            0xce1,
            0xcf1,
            0xcf2,
            0xd04,
            0xd0c,
            0xd0e,
            0xd10,
            0xd12,
            0xd3a,
            0xd3d,
            0xd3d,
            0xd4e,
            0xd4e,
            0xd54,
            0xd56,
            0xd5f,
            0xd61,
            0xd7a,
            0xd7f,
            0xd85,
            0xd96,
            0xd9a,
            0xdb1,
            0xdb3,
            0xdbb,
            0xdbd,
            0xdbd,
            0xdc0,
            0xdc6,
            0xe01,
            0xe30,
            0xe32,
            0xe32,
            0xe40,
            0xe46,
            0xe81,
            0xe82,
            0xe84,
            0xe84,
            0xe86,
            0xe8a,
            0xe8c,
            0xea3,
            0xea5,
            0xea5,
            0xea7,
            0xeb0,
            0xeb2,
            0xeb2,
            0xebd,
            0xebd,
            0xec0,
            0xec4,
            0xec6,
            0xec6,
            0xedc,
            0xedf,
            0xf00,
            0xf00,
            0xf40,
            0xf47,
            0xf49,
            0xf6c,
            0xf88,
            0xf8c,
            0x1000,
            0x102a,
            0x103f,
            0x103f,
            0x1050,
            0x1055,
            0x105a,
            0x105d,
            0x1061,
            0x1061,
            0x1065,
            0x1066,
            0x106e,
            0x1070,
            0x1075,
            0x1081,
            0x108e,
            0x108e,
            0x10a0,
            0x10c5,
            0x10c7,
            0x10c7,
            0x10cd,
            0x10cd,
            0x10d0,
            0x10fa,
            0x10fc,
            0x1248,
            0x124a,
            0x124d,
            0x1250,
            0x1256,
            0x1258,
            0x1258,
            0x125a,
            0x125d,
            0x1260,
            0x1288,
            0x128a,
            0x128d,
            0x1290,
            0x12b0,
            0x12b2,
            0x12b5,
            0x12b8,
            0x12be,
            0x12c0,
            0x12c0,
            0x12c2,
            0x12c5,
            0x12c8,
            0x12d6,
            0x12d8,
            0x1310,
            0x1312,
            0x1315,
            0x1318,
            0x135a,
            0x1380,
            0x138f,
            0x13a0,
            0x13f5,
            0x13f8,
            0x13fd,
            0x1401,
            0x166c,
            0x166f,
            0x167f,
            0x1681,
            0x169a,
            0x16a0,
            0x16ea,
            0x16ee,
            0x16f8,
            0x1700,
            0x170c,
            0x170e,
            0x1711,
            0x1720,
            0x1731,
            0x1740,
            0x1751,
            0x1760,
            0x176c,
            0x176e,
            0x1770,
            0x1780,
            0x17b3,
            0x17d7,
            0x17d7,
            0x17dc,
            0x17dc,
            0x1820,
            0x1878,
            0x1880,
            0x1884,
            0x1887,
            0x18a8,
            0x18aa,
            0x18aa,
            0x18b0,
            0x18f5,
            0x1900,
            0x191e,
            0x1950,
            0x196d,
            0x1970,
            0x1974,
            0x1980,
            0x19ab,
            0x19b0,
            0x19c9,
            0x1a00,
            0x1a16,
            0x1a20,
            0x1a54,
            0x1aa7,
            0x1aa7,
            0x1b05,
            0x1b33,
            0x1b45,
            0x1b4b,
            0x1b83,
            0x1ba0,
            0x1bae,
            0x1baf,
            0x1bba,
            0x1be5,
            0x1c00,
            0x1c23,
            0x1c4d,
            0x1c4f,
            0x1c5a,
            0x1c7d,
            0x1c80,
            0x1c88,
            0x1c90,
            0x1cba,
            0x1cbd,
            0x1cbf,
            0x1ce9,
            0x1cec,
            0x1cee,
            0x1cf3,
            0x1cf5,
            0x1cf6,
            0x1cfa,
            0x1cfa,
            0x1d00,
            0x1dbf,
            0x1e00,
            0x1f15,
            0x1f18,
            0x1f1d,
            0x1f20,
            0x1f45,
            0x1f48,
            0x1f4d,
            0x1f50,
            0x1f57,
            0x1f59,
            0x1f59,
            0x1f5b,
            0x1f5b,
            0x1f5d,
            0x1f5d,
            0x1f5f,
            0x1f7d,
            0x1f80,
            0x1fb4,
            0x1fb6,
            0x1fbc,
            0x1fbe,
            0x1fbe,
            0x1fc2,
            0x1fc4,
            0x1fc6,
            0x1fcc,
            0x1fd0,
            0x1fd3,
            0x1fd6,
            0x1fdb,
            0x1fe0,
            0x1fec,
            0x1ff2,
            0x1ff4,
            0x1ff6,
            0x1ffc,
            0x2071,
            0x2071,
            0x207f,
            0x207f,
            0x2090,
            0x209c,
            0x2102,
            0x2102,
            0x2107,
            0x2107,
            0x210a,
            0x2113,
            0x2115,
            0x2115,
            0x2119,
            0x211d,
            0x2124,
            0x2124,
            0x2126,
            0x2126,
            0x2128,
            0x2128,
            0x212a,
            0x212d,
            0x212f,
            0x2139,
            0x213c,
            0x213f,
            0x2145,
            0x2149,
            0x214e,
            0x214e,
            0x2160,
            0x2188,
            0x2c00,
            0x2c2e,
            0x2c30,
            0x2c5e,
            0x2c60,
            0x2ce4,
            0x2ceb,
            0x2cee,
            0x2cf2,
            0x2cf3,
            0x2d00,
            0x2d25,
            0x2d27,
            0x2d27,
            0x2d2d,
            0x2d2d,
            0x2d30,
            0x2d67,
            0x2d6f,
            0x2d6f,
            0x2d80,
            0x2d96,
            0x2da0,
            0x2da6,
            0x2da8,
            0x2dae,
            0x2db0,
            0x2db6,
            0x2db8,
            0x2dbe,
            0x2dc0,
            0x2dc6,
            0x2dc8,
            0x2dce,
            0x2dd0,
            0x2dd6,
            0x2dd8,
            0x2dde,
            0x2e2f,
            0x2e2f,
            0x3005,
            0x3007,
            0x3021,
            0x3029,
            0x3031,
            0x3035,
            0x3038,
            0x303c,
            0x3041,
            0x3096,
            0x309d,
            0x309f,
            0x30a1,
            0x30fa,
            0x30fc,
            0x30ff,
            0x3105,
            0x312f,
            0x3131,
            0x318e,
            0x31a0,
            0x31bf,
            0x31f0,
            0x31ff,
            0x3400,
            0x4dbf,
            0x4e00,
            0x9ffc,
            0xa000,
            0xa48c,
            0xa4d0,
            0xa4fd,
            0xa500,
            0xa60c,
            0xa610,
            0xa61f,
            0xa62a,
            0xa62b,
            0xa640,
            0xa66e,
            0xa67f,
            0xa69d,
            0xa6a0,
            0xa6ef,
            0xa717,
            0xa71f,
            0xa722,
            0xa788,
            0xa78b,
            0xa7bf,
            0xa7c2,
            0xa7ca,
            0xa7f5,
            0xa801,
            0xa803,
            0xa805,
            0xa807,
            0xa80a,
            0xa80c,
            0xa822,
            0xa840,
            0xa873,
            0xa882,
            0xa8b3,
            0xa8f2,
            0xa8f7,
            0xa8fb,
            0xa8fb,
            0xa8fd,
            0xa8fe,
            0xa90a,
            0xa925,
            0xa930,
            0xa946,
            0xa960,
            0xa97c,
            0xa984,
            0xa9b2,
            0xa9cf,
            0xa9cf,
            0xa9e0,
            0xa9e4,
            0xa9e6,
            0xa9ef,
            0xa9fa,
            0xa9fe,
            0xaa00,
            0xaa28,
            0xaa40,
            0xaa42,
            0xaa44,
            0xaa4b,
            0xaa60,
            0xaa76,
            0xaa7a,
            0xaa7a,
            0xaa7e,
            0xaaaf,
            0xaab1,
            0xaab1,
            0xaab5,
            0xaab6,
            0xaab9,
            0xaabd,
            0xaac0,
            0xaac0,
            0xaac2,
            0xaac2,
            0xaadb,
            0xaadd,
            0xaae0,
            0xaaea,
            0xaaf2,
            0xaaf4,
            0xab01,
            0xab06,
            0xab09,
            0xab0e,
            0xab11,
            0xab16,
            0xab20,
            0xab26,
            0xab28,
            0xab2e,
            0xab30,
            0xab5a,
            0xab5c,
            0xab69,
            0xab70,
            0xabe2,
            0xac00,
            0xd7a3,
            0xd7b0,
            0xd7c6,
            0xd7cb,
            0xd7fb,
            0xf900,
            0xfa6d,
            0xfa70,
            0xfad9,
            0xfb00,
            0xfb06,
            0xfb13,
            0xfb17,
            0xfb1d,
            0xfb1d,
            0xfb1f,
            0xfb28,
            0xfb2a,
            0xfb36,
            0xfb38,
            0xfb3c,
            0xfb3e,
            0xfb3e,
            0xfb40,
            0xfb41,
            0xfb43,
            0xfb44,
            0xfb46,
            0xfbb1,
            0xfbd3,
            0xfc5d,
            0xfc64,
            0xfd3d,
            0xfd50,
            0xfd8f,
            0xfd92,
            0xfdc7,
            0xfdf0,
            0xfdf9,
            0xfe71,
            0xfe71,
            0xfe73,
            0xfe73,
            0xfe77,
            0xfe77,
            0xfe79,
            0xfe79,
            0xfe7b,
            0xfe7b,
            0xfe7d,
            0xfe7d,
            0xfe7f,
            0xfefc,
            0xff21,
            0xff3a,
            0xff41,
            0xff5a,
            0xff66,
            0xff9d,
            0xffa0,
            0xffbe,
            0xffc2,
            0xffc7,
            0xffca,
            0xffcf,
            0xffd2,
            0xffd7,
            0xffda,
            0xffdc,
            0x10000,
            0x1000b,
            0x1000d,
            0x10026,
            0x10028,
            0x1003a,
            0x1003c,
            0x1003d,
            0x1003f,
            0x1004d,
            0x10050,
            0x1005d,
            0x10080,
            0x100fa,
            0x10140,
            0x10174,
            0x10280,
            0x1029c,
            0x102a0,
            0x102d0,
            0x10300,
            0x1031f,
            0x1032d,
            0x1034a,
            0x10350,
            0x10375,
            0x10380,
            0x1039d,
            0x103a0,
            0x103c3,
            0x103c8,
            0x103cf,
            0x103d1,
            0x103d5,
            0x10400,
            0x1049d,
            0x104b0,
            0x104d3,
            0x104d8,
            0x104fb,
            0x10500,
            0x10527,
            0x10530,
            0x10563,
            0x10600,
            0x10736,
            0x10740,
            0x10755,
            0x10760,
            0x10767,
            0x10800,
            0x10805,
            0x10808,
            0x10808,
            0x1080a,
            0x10835,
            0x10837,
            0x10838,
            0x1083c,
            0x1083c,
            0x1083f,
            0x10855,
            0x10860,
            0x10876,
            0x10880,
            0x1089e,
            0x108e0,
            0x108f2,
            0x108f4,
            0x108f5,
            0x10900,
            0x10915,
            0x10920,
            0x10939,
            0x10980,
            0x109b7,
            0x109be,
            0x109bf,
            0x10a00,
            0x10a00,
            0x10a10,
            0x10a13,
            0x10a15,
            0x10a17,
            0x10a19,
            0x10a35,
            0x10a60,
            0x10a7c,
            0x10a80,
            0x10a9c,
            0x10ac0,
            0x10ac7,
            0x10ac9,
            0x10ae4,
            0x10b00,
            0x10b35,
            0x10b40,
            0x10b55,
            0x10b60,
            0x10b72,
            0x10b80,
            0x10b91,
            0x10c00,
            0x10c48,
            0x10c80,
            0x10cb2,
            0x10cc0,
            0x10cf2,
            0x10d00,
            0x10d23,
            0x10e80,
            0x10ea9,
            0x10eb0,
            0x10eb1,
            0x10f00,
            0x10f1c,
            0x10f27,
            0x10f27,
            0x10f30,
            0x10f45,
            0x10fb0,
            0x10fc4,
            0x10fe0,
            0x10ff6,
            0x11003,
            0x11037,
            0x11083,
            0x110af,
            0x110d0,
            0x110e8,
            0x11103,
            0x11126,
            0x11144,
            0x11144,
            0x11147,
            0x11147,
            0x11150,
            0x11172,
            0x11176,
            0x11176,
            0x11183,
            0x111b2,
            0x111c1,
            0x111c4,
            0x111da,
            0x111da,
            0x111dc,
            0x111dc,
            0x11200,
            0x11211,
            0x11213,
            0x1122b,
            0x11280,
            0x11286,
            0x11288,
            0x11288,
            0x1128a,
            0x1128d,
            0x1128f,
            0x1129d,
            0x1129f,
            0x112a8,
            0x112b0,
            0x112de,
            0x11305,
            0x1130c,
            0x1130f,
            0x11310,
            0x11313,
            0x11328,
            0x1132a,
            0x11330,
            0x11332,
            0x11333,
            0x11335,
            0x11339,
            0x1133d,
            0x1133d,
            0x11350,
            0x11350,
            0x1135d,
            0x11361,
            0x11400,
            0x11434,
            0x11447,
            0x1144a,
            0x1145f,
            0x11461,
            0x11480,
            0x114af,
            0x114c4,
            0x114c5,
            0x114c7,
            0x114c7,
            0x11580,
            0x115ae,
            0x115d8,
            0x115db,
            0x11600,
            0x1162f,
            0x11644,
            0x11644,
            0x11680,
            0x116aa,
            0x116b8,
            0x116b8,
            0x11700,
            0x1171a,
            0x11800,
            0x1182b,
            0x118a0,
            0x118df,
            0x118ff,
            0x11906,
            0x11909,
            0x11909,
            0x1190c,
            0x11913,
            0x11915,
            0x11916,
            0x11918,
            0x1192f,
            0x1193f,
            0x1193f,
            0x11941,
            0x11941,
            0x119a0,
            0x119a7,
            0x119aa,
            0x119d0,
            0x119e1,
            0x119e1,
            0x119e3,
            0x119e3,
            0x11a00,
            0x11a00,
            0x11a0b,
            0x11a32,
            0x11a3a,
            0x11a3a,
            0x11a50,
            0x11a50,
            0x11a5c,
            0x11a89,
            0x11a9d,
            0x11a9d,
            0x11ac0,
            0x11af8,
            0x11c00,
            0x11c08,
            0x11c0a,
            0x11c2e,
            0x11c40,
            0x11c40,
            0x11c72,
            0x11c8f,
            0x11d00,
            0x11d06,
            0x11d08,
            0x11d09,
            0x11d0b,
            0x11d30,
            0x11d46,
            0x11d46,
            0x11d60,
            0x11d65,
            0x11d67,
            0x11d68,
            0x11d6a,
            0x11d89,
            0x11d98,
            0x11d98,
            0x11ee0,
            0x11ef2,
            0x11fb0,
            0x11fb0,
            0x12000,
            0x12399,
            0x12400,
            0x1246e,
            0x12480,
            0x12543,
            0x13000,
            0x1342e,
            0x14400,
            0x14646,
            0x16800,
            0x16a38,
            0x16a40,
            0x16a5e,
            0x16ad0,
            0x16aed,
            0x16b00,
            0x16b2f,
            0x16b40,
            0x16b43,
            0x16b63,
            0x16b77,
            0x16b7d,
            0x16b8f,
            0x16e40,
            0x16e7f,
            0x16f00,
            0x16f4a,
            0x16f50,
            0x16f50,
            0x16f93,
            0x16f9f,
            0x16fe0,
            0x16fe1,
            0x16fe3,
            0x16fe3,
            0x17000,
            0x187f7,
            0x18800,
            0x18cd5,
            0x18d00,
            0x18d08,
            0x1b000,
            0x1b11e,
            0x1b150,
            0x1b152,
            0x1b164,
            0x1b167,
            0x1b170,
            0x1b2fb,
            0x1bc00,
            0x1bc6a,
            0x1bc70,
            0x1bc7c,
            0x1bc80,
            0x1bc88,
            0x1bc90,
            0x1bc99,
            0x1d400,
            0x1d454,
            0x1d456,
            0x1d49c,
            0x1d49e,
            0x1d49f,
            0x1d4a2,
            0x1d4a2,
            0x1d4a5,
            0x1d4a6,
            0x1d4a9,
            0x1d4ac,
            0x1d4ae,
            0x1d4b9,
            0x1d4bb,
            0x1d4bb,
            0x1d4bd,
            0x1d4c3,
            0x1d4c5,
            0x1d505,
            0x1d507,
            0x1d50a,
            0x1d50d,
            0x1d514,
            0x1d516,
            0x1d51c,
            0x1d51e,
            0x1d539,
            0x1d53b,
            0x1d53e,
            0x1d540,
            0x1d544,
            0x1d546,
            0x1d546,
            0x1d54a,
            0x1d550,
            0x1d552,
            0x1d6a5,
            0x1d6a8,
            0x1d6c0,
            0x1d6c2,
            0x1d6da,
            0x1d6dc,
            0x1d6fa,
            0x1d6fc,
            0x1d714,
            0x1d716,
            0x1d734,
            0x1d736,
            0x1d74e,
            0x1d750,
            0x1d76e,
            0x1d770,
            0x1d788,
            0x1d78a,
            0x1d7a8,
            0x1d7aa,
            0x1d7c2,
            0x1d7c4,
            0x1d7cb,
            0x1e100,
            0x1e12c,
            0x1e137,
            0x1e13d,
            0x1e14e,
            0x1e14e,
            0x1e2c0,
            0x1e2eb,
            0x1e800,
            0x1e8c4,
            0x1e900,
            0x1e943,
            0x1e94b,
            0x1e94b,
            0x1ee00,
            0x1ee03,
            0x1ee05,
            0x1ee1f,
            0x1ee21,
            0x1ee22,
            0x1ee24,
            0x1ee24,
            0x1ee27,
            0x1ee27,
            0x1ee29,
            0x1ee32,
            0x1ee34,
            0x1ee37,
            0x1ee39,
            0x1ee39,
            0x1ee3b,
            0x1ee3b,
            0x1ee42,
            0x1ee42,
            0x1ee47,
            0x1ee47,
            0x1ee49,
            0x1ee49,
            0x1ee4b,
            0x1ee4b,
            0x1ee4d,
            0x1ee4f,
            0x1ee51,
            0x1ee52,
            0x1ee54,
            0x1ee54,
            0x1ee57,
            0x1ee57,
            0x1ee59,
            0x1ee59,
            0x1ee5b,
            0x1ee5b,
            0x1ee5d,
            0x1ee5d,
            0x1ee5f,
            0x1ee5f,
            0x1ee61,
            0x1ee62,
            0x1ee64,
            0x1ee64,
            0x1ee67,
            0x1ee6a,
            0x1ee6c,
            0x1ee72,
            0x1ee74,
            0x1ee77,
            0x1ee79,
            0x1ee7c,
            0x1ee7e,
            0x1ee7e,
            0x1ee80,
            0x1ee89,
            0x1ee8b,
            0x1ee9b,
            0x1eea1,
            0x1eea3,
            0x1eea5,
            0x1eea9,
            0x1eeab,
            0x1eebb,
            0x20000,
            0x2a6dd,
            0x2a700,
            0x2b734,
            0x2b740,
            0x2b81d,
            0x2b820,
            0x2cea1,
            0x2ceb0,
            0x2ebe0,
            0x2f800,
            0x2fa1d,
            0x30000,
            0x3134a
        };

        private static TokenType? NFA_PYTHON_111(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (((ch >= 'A' && ch <= 'Z' ) || ((ch == '_') || (ch >= 'a' && ch <= 'z' ))) || ((ch >= (char) 128) && CheckIntervals(NFA_MOVES_PYTHON_111, ch))) {
                nextStates.Set(224);
                if (validTypes.Contains(TokenType.NAME)) {
                    return TokenType.NAME;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_112(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                if (validTypes.Contains(TokenType.PEG_PARSER)) {
                    return TokenType.PEG_PARSER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_113(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'w') {
                nextStates.Set(317);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_114(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.Set(154);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_115(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.Set(8);
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    return TokenType.BINNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_116(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_117(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                if (validTypes.Contains(TokenType.DEL)) {
                    return TokenType.DEL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_118(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '*') {
                nextStates.Set(174);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_119(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(152);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_120(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.Set(398);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_121(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(59);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_122(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '@') {
                if (validTypes.Contains(TokenType.AT)) {
                    return TokenType.AT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_123(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.ANDASSIGN)) {
                    return TokenType.ANDASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_124(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(151);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_125(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(455);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_126(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '#') {
                nextStates.Set(415);
                if (validTypes.Contains(TokenType.COMMENT)) {
                    return TokenType.COMMENT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_127(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(294);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_128(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                if (validTypes.Contains(TokenType.EXCEPT)) {
                    return TokenType.EXCEPT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_129(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                nextStates.Set(158);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_130(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                if (validTypes.Contains(TokenType.GLOBAL)) {
                    return TokenType.GLOBAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_131(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                if (validTypes.Contains(TokenType.IN)) {
                    return TokenType.IN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_132(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(389);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_133(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x7f ) {
                nextStates.Set(59);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_134(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(309);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_135(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.NONE)) {
                    return TokenType.NONE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_136(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                if (validTypes.Contains(TokenType.NOT)) {
                    return TokenType.NOT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_137(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_138(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.COLONEQUALS)) {
                    return TokenType.COLONEQUALS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_139(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_140(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '(') {
                if (validTypes.Contains(TokenType.LPAREN)) {
                    return TokenType.LPAREN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_141(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_142(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(298);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_143(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(231);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_144(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '-') {
                nextStates.Set(397);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_145(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(351);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_146(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(332);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_147(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '<') {
                if (validTypes.Contains(TokenType.LSHIFT)) {
                    return TokenType.LSHIFT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_148(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(195);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_149(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_150(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(369);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_151(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                if (validTypes.Contains(TokenType.IS)) {
                    return TokenType.IS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_152(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(121);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_153(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(393);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_154(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.TRUE)) {
                    return TokenType.TRUE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_155(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'm') {
                nextStates.Set(413);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_156(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_157(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '&') {
                nextStates.Set(123);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_158(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.EQ)) {
                    return TokenType.EQ;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_159(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(462);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_160(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '[') {
                if (validTypes.Contains(TokenType.LBRACKET)) {
                    return TokenType.LBRACKET;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_161(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '?') {
                nextStates.Set(288);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_162(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_163(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(178);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_164(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_165(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'y') {
                nextStates.Set(281);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_166(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'c') {
                nextStates.Set(436);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_167(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'c') {
                nextStates.Set(392);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_168(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.Set(271);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_169(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '>') {
                if (validTypes.Contains(TokenType.RARROW)) {
                    return TokenType.RARROW;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_170(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_171(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_172(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(407);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_173(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.PLUSASSIGN)) {
                    return TokenType.PLUSASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_174(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '*') {
                if (validTypes.Contains(TokenType.STAR_STAR)) {
                    return TokenType.STAR_STAR;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_175(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                if (validTypes.Contains(TokenType.PASS)) {
                    return TokenType.PASS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_176(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(179);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_177(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '>') {
                nextStates.Set(339);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_178(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.ELSE)) {
                    return TokenType.ELSE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_179(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(394);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_180(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_181(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(300);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_182(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(234);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_183(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(327);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_184(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(256);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_185(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'p') {
                nextStates.Set(409);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_186(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(381);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_187(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_188(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_189(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(77);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_190(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '>') {
                if (validTypes.Contains(TokenType.RSHIFT)) {
                    return TokenType.RSHIFT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_191(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(420);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_192(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(114);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_193(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '|') {
                if (validTypes.Contains(TokenType.BIT_OR)) {
                    return TokenType.BIT_OR;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_194(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'd') {
                nextStates.Set(153);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_195(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(97);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_196(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.STARASSIGN)) {
                    return TokenType.STARASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_197(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '-') {
                nextStates.Set(169);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_198(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(442);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_199(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.STARSTARASSIGN)) {
                    return TokenType.STARSTARASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_200(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(263);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_201(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'y') {
                nextStates.Set(340);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_202(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.Set(348);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_203(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(279);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_204(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'k') {
                if (validTypes.Contains(TokenType.BREAK)) {
                    return TokenType.BREAK;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_205(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.ORASSIGN)) {
                    return TokenType.ORASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_206(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '@') {
                nextStates.Set(105);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_207(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                if (validTypes.Contains(TokenType._ASSERT)) {
                    return TokenType._ASSERT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_208(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.SLASHASSIGN)) {
                    return TokenType.SLASHASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_209(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                if (validTypes.Contains(TokenType.ELIF)) {
                    return TokenType.ELIF;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_210(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                if (validTypes.Contains(TokenType.CLASS)) {
                    return TokenType.CLASS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_211(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(385);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_212(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'c') {
                nextStates.Set(338);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_213(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '}') {
                if (validTypes.Contains(TokenType.RBRACE)) {
                    return TokenType.RBRACE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_214(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\n') {
                if (validTypes.Contains(TokenType.CONTINUE_LINE)) {
                    return TokenType.CONTINUE_LINE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_215(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'p') {
                nextStates.Set(286);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_216(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(278);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_217(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ')') {
                if (validTypes.Contains(TokenType.RPAREN)) {
                    return TokenType.RPAREN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_218(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                if (validTypes.Contains(TokenType.ELLIPSIS)) {
                    return TokenType.ELLIPSIS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_219(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '<') {
                nextStates.Set(147);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_220(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'h') {
                if (validTypes.Contains(TokenType.WITH)) {
                    return TokenType.WITH;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_221(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(418);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_222(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_223(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(270);
            }
            return null;
        }

        private static int[] NFA_MOVES_PYTHON_224 = {
            '0',
            '9',
            'A',
            'Z',
            '_',
            '_',
            'a',
            'z',
            0xaa,
            0xaa,
            0xb5,
            0xb5,
            0xba,
            0xba,
            0xc0,
            0xd6,
            0xd8,
            0xf6,
            0xf8,
            0x13e,
            0x141,
            0x2c1,
            0x2c6,
            0x2d1,
            0x2e0,
            0x2e4,
            0x2ec,
            0x2ec,
            0x2ee,
            0x2ee,
            0x300,
            0x374,
            0x376,
            0x377,
            0x37b,
            0x37d,
            0x37f,
            0x37f,
            0x386,
            0x386,
            0x388,
            0x38a,
            0x38c,
            0x38c,
            0x38e,
            0x3a1,
            0x3a3,
            0x3f5,
            0x3f7,
            0x481,
            0x483,
            0x487,
            0x48a,
            0x52f,
            0x531,
            0x556,
            0x559,
            0x559,
            0x560,
            0x588,
            0x591,
            0x5bd,
            0x5bf,
            0x5bf,
            0x5c1,
            0x5c2,
            0x5c4,
            0x5c5,
            0x5c7,
            0x5c7,
            0x5d0,
            0x5ea,
            0x5ef,
            0x5f2,
            0x610,
            0x61a,
            0x620,
            0x669,
            0x66e,
            0x6d3,
            0x6d5,
            0x6dc,
            0x6df,
            0x6e8,
            0x6ea,
            0x6fc,
            0x6ff,
            0x6ff,
            0x710,
            0x74a,
            0x74d,
            0x7b1,
            0x7c0,
            0x7f5,
            0x7fa,
            0x7fa,
            0x7fd,
            0x7fd,
            0x800,
            0x82d,
            0x840,
            0x85b,
            0x860,
            0x86a,
            0x8a0,
            0x8b4,
            0x8b6,
            0x8c7,
            0x8d3,
            0x8e1,
            0x8e3,
            0x963,
            0x966,
            0x96f,
            0x971,
            0x983,
            0x985,
            0x98c,
            0x98f,
            0x990,
            0x993,
            0x9a8,
            0x9aa,
            0x9b0,
            0x9b2,
            0x9b2,
            0x9b6,
            0x9b9,
            0x9bc,
            0x9c4,
            0x9c7,
            0x9c8,
            0x9cb,
            0x9ce,
            0x9d7,
            0x9d7,
            0x9dc,
            0x9dd,
            0x9df,
            0x9e3,
            0x9e6,
            0x9f1,
            0x9fc,
            0x9fc,
            0x9fe,
            0x9fe,
            0xa01,
            0xa03,
            0xa05,
            0xa0a,
            0xa0f,
            0xa10,
            0xa13,
            0xa28,
            0xa2a,
            0xa30,
            0xa32,
            0xa33,
            0xa35,
            0xa36,
            0xa38,
            0xa39,
            0xa3c,
            0xa3c,
            0xa3e,
            0xa42,
            0xa47,
            0xa48,
            0xa4b,
            0xa4d,
            0xa51,
            0xa51,
            0xa59,
            0xa5c,
            0xa5e,
            0xa5e,
            0xa66,
            0xa75,
            0xa81,
            0xa83,
            0xa85,
            0xa8d,
            0xa8f,
            0xa91,
            0xa93,
            0xaa8,
            0xaaa,
            0xab0,
            0xab2,
            0xab3,
            0xab5,
            0xab9,
            0xabc,
            0xac5,
            0xac7,
            0xac9,
            0xacb,
            0xacd,
            0xad0,
            0xad0,
            0xae0,
            0xae3,
            0xae6,
            0xaef,
            0xaf9,
            0xaff,
            0xb01,
            0xb03,
            0xb05,
            0xb0c,
            0xb0f,
            0xb10,
            0xb13,
            0xb28,
            0xb2a,
            0xb30,
            0xb32,
            0xb33,
            0xb35,
            0xb39,
            0xb3c,
            0xb44,
            0xb47,
            0xb48,
            0xb4b,
            0xb4d,
            0xb55,
            0xb57,
            0xb5c,
            0xb5d,
            0xb5f,
            0xb63,
            0xb66,
            0xb6f,
            0xb71,
            0xb71,
            0xb82,
            0xb83,
            0xb85,
            0xb8a,
            0xb8e,
            0xb90,
            0xb92,
            0xb95,
            0xb99,
            0xb9a,
            0xb9c,
            0xb9c,
            0xb9e,
            0xb9f,
            0xba3,
            0xba4,
            0xba8,
            0xbaa,
            0xbae,
            0xbb9,
            0xbbe,
            0xbc2,
            0xbc6,
            0xbc8,
            0xbca,
            0xbcd,
            0xbd0,
            0xbd0,
            0xbd7,
            0xbd7,
            0xbe6,
            0xbef,
            0xc00,
            0xc0c,
            0xc0e,
            0xc10,
            0xc12,
            0xc28,
            0xc2a,
            0xc39,
            0xc3d,
            0xc44,
            0xc46,
            0xc48,
            0xc4a,
            0xc4d,
            0xc55,
            0xc56,
            0xc58,
            0xc5a,
            0xc60,
            0xc63,
            0xc66,
            0xc6f,
            0xc80,
            0xc83,
            0xc85,
            0xc8c,
            0xc8e,
            0xc90,
            0xc92,
            0xca8,
            0xcaa,
            0xcb3,
            0xcb5,
            0xcb9,
            0xcbc,
            0xcc4,
            0xcc6,
            0xcc8,
            0xcca,
            0xccd,
            0xcd5,
            0xcd6,
            0xcde,
            0xcde,
            0xce0,
            0xce3,
            0xce6,
            0xcef,
            0xcf1,
            0xcf2,
            0xd00,
            0xd0c,
            0xd0e,
            0xd10,
            0xd12,
            0xd44,
            0xd46,
            0xd48,
            0xd4a,
            0xd4e,
            0xd54,
            0xd57,
            0xd5f,
            0xd63,
            0xd66,
            0xd6f,
            0xd7a,
            0xd7f,
            0xd81,
            0xd83,
            0xd85,
            0xd96,
            0xd9a,
            0xdb1,
            0xdb3,
            0xdbb,
            0xdbd,
            0xdbd,
            0xdc0,
            0xdc6,
            0xdca,
            0xdca,
            0xdcf,
            0xdd4,
            0xdd6,
            0xdd6,
            0xdd8,
            0xddf,
            0xde6,
            0xdef,
            0xdf2,
            0xdf3,
            0xe01,
            0xe3a,
            0xe40,
            0xe4e,
            0xe50,
            0xe59,
            0xe81,
            0xe82,
            0xe84,
            0xe84,
            0xe86,
            0xe8a,
            0xe8c,
            0xea3,
            0xea5,
            0xea5,
            0xea7,
            0xebd,
            0xec0,
            0xec4,
            0xec6,
            0xec6,
            0xec8,
            0xecd,
            0xed0,
            0xed9,
            0xedc,
            0xedf,
            0xf00,
            0xf00,
            0xf18,
            0xf19,
            0xf20,
            0xf29,
            0xf35,
            0xf35,
            0xf37,
            0xf37,
            0xf39,
            0xf39,
            0xf3e,
            0xf47,
            0xf49,
            0xf6c,
            0xf71,
            0xf84,
            0xf86,
            0xf97,
            0xf99,
            0xfbc,
            0xfc6,
            0xfc6,
            0x1000,
            0x1049,
            0x1050,
            0x109d,
            0x10a0,
            0x10c5,
            0x10c7,
            0x10c7,
            0x10cd,
            0x10cd,
            0x10d0,
            0x10fa,
            0x10fc,
            0x1248,
            0x124a,
            0x124d,
            0x1250,
            0x1256,
            0x1258,
            0x1258,
            0x125a,
            0x125d,
            0x1260,
            0x1288,
            0x128a,
            0x128d,
            0x1290,
            0x12b0,
            0x12b2,
            0x12b5,
            0x12b8,
            0x12be,
            0x12c0,
            0x12c0,
            0x12c2,
            0x12c5,
            0x12c8,
            0x12d6,
            0x12d8,
            0x1310,
            0x1312,
            0x1315,
            0x1318,
            0x135a,
            0x135d,
            0x135f,
            0x1380,
            0x138f,
            0x13a0,
            0x13f5,
            0x13f8,
            0x13fd,
            0x1401,
            0x166c,
            0x166f,
            0x167f,
            0x1681,
            0x169a,
            0x16a0,
            0x16ea,
            0x16ee,
            0x16f8,
            0x1700,
            0x170c,
            0x170e,
            0x1714,
            0x1720,
            0x1734,
            0x1740,
            0x1753,
            0x1760,
            0x176c,
            0x176e,
            0x1770,
            0x1772,
            0x1773,
            0x1780,
            0x17d3,
            0x17d7,
            0x17d7,
            0x17dc,
            0x17dd,
            0x17e0,
            0x17e9,
            0x180b,
            0x180d,
            0x1810,
            0x1819,
            0x1820,
            0x1878,
            0x1880,
            0x18aa,
            0x18b0,
            0x18f5,
            0x1900,
            0x191e,
            0x1920,
            0x192b,
            0x1930,
            0x193b,
            0x1946,
            0x196d,
            0x1970,
            0x1974,
            0x1980,
            0x19ab,
            0x19b0,
            0x19c9,
            0x19d0,
            0x19d9,
            0x1a00,
            0x1a1b,
            0x1a20,
            0x1a5e,
            0x1a60,
            0x1a7c,
            0x1a7f,
            0x1a89,
            0x1a90,
            0x1a99,
            0x1aa7,
            0x1aa7,
            0x1ab0,
            0x1abd,
            0x1abf,
            0x1ac0,
            0x1b00,
            0x1b4b,
            0x1b50,
            0x1b59,
            0x1b6b,
            0x1b73,
            0x1b80,
            0x1bf3,
            0x1c00,
            0x1c37,
            0x1c40,
            0x1c49,
            0x1c4d,
            0x1c7d,
            0x1c80,
            0x1c88,
            0x1c90,
            0x1cba,
            0x1cbd,
            0x1cbf,
            0x1cd0,
            0x1cd2,
            0x1cd4,
            0x1cfa,
            0x1d00,
            0x1df9,
            0x1dfb,
            0x1f15,
            0x1f18,
            0x1f1d,
            0x1f20,
            0x1f45,
            0x1f48,
            0x1f4d,
            0x1f50,
            0x1f57,
            0x1f59,
            0x1f59,
            0x1f5b,
            0x1f5b,
            0x1f5d,
            0x1f5d,
            0x1f5f,
            0x1f7d,
            0x1f80,
            0x1fb4,
            0x1fb6,
            0x1fbc,
            0x1fbe,
            0x1fbe,
            0x1fc2,
            0x1fc4,
            0x1fc6,
            0x1fcc,
            0x1fd0,
            0x1fd3,
            0x1fd6,
            0x1fdb,
            0x1fe0,
            0x1fec,
            0x1ff2,
            0x1ff4,
            0x1ff6,
            0x1ffc,
            0x203f,
            0x2040,
            0x2054,
            0x2054,
            0x2071,
            0x2071,
            0x207f,
            0x207f,
            0x2090,
            0x209c,
            0x20d0,
            0x20dc,
            0x20e1,
            0x20e1,
            0x20e5,
            0x20f0,
            0x2102,
            0x2102,
            0x2107,
            0x2107,
            0x210a,
            0x2113,
            0x2115,
            0x2115,
            0x2119,
            0x211d,
            0x2124,
            0x2124,
            0x2126,
            0x2126,
            0x2128,
            0x2128,
            0x212a,
            0x212d,
            0x212f,
            0x2139,
            0x213c,
            0x213f,
            0x2145,
            0x2149,
            0x214e,
            0x214e,
            0x2160,
            0x2188,
            0x2c00,
            0x2c2e,
            0x2c30,
            0x2c5e,
            0x2c60,
            0x2ce4,
            0x2ceb,
            0x2cf3,
            0x2d00,
            0x2d25,
            0x2d27,
            0x2d27,
            0x2d2d,
            0x2d2d,
            0x2d30,
            0x2d67,
            0x2d6f,
            0x2d6f,
            0x2d7f,
            0x2d96,
            0x2da0,
            0x2da6,
            0x2da8,
            0x2dae,
            0x2db0,
            0x2db6,
            0x2db8,
            0x2dbe,
            0x2dc0,
            0x2dc6,
            0x2dc8,
            0x2dce,
            0x2dd0,
            0x2dd6,
            0x2dd8,
            0x2dde,
            0x2de0,
            0x2dff,
            0x2e2f,
            0x2e2f,
            0x3005,
            0x3007,
            0x3021,
            0x302f,
            0x3031,
            0x3035,
            0x3038,
            0x303c,
            0x3041,
            0x3096,
            0x3099,
            0x309a,
            0x309d,
            0x309f,
            0x30a1,
            0x30fa,
            0x30fc,
            0x30ff,
            0x3105,
            0x312f,
            0x3131,
            0x318e,
            0x31a0,
            0x31bf,
            0x31f0,
            0x31ff,
            0x3400,
            0x4dbf,
            0x4e00,
            0x9ffc,
            0xa000,
            0xa48c,
            0xa4d0,
            0xa4fd,
            0xa500,
            0xa60c,
            0xa610,
            0xa62b,
            0xa640,
            0xa66f,
            0xa674,
            0xa67d,
            0xa67f,
            0xa6f1,
            0xa717,
            0xa71f,
            0xa722,
            0xa788,
            0xa78b,
            0xa7bf,
            0xa7c2,
            0xa7ca,
            0xa7f5,
            0xa827,
            0xa82c,
            0xa82c,
            0xa840,
            0xa873,
            0xa880,
            0xa8c5,
            0xa8d0,
            0xa8d9,
            0xa8e0,
            0xa8f7,
            0xa8fb,
            0xa8fb,
            0xa8fd,
            0xa92d,
            0xa930,
            0xa953,
            0xa960,
            0xa97c,
            0xa980,
            0xa9c0,
            0xa9cf,
            0xa9d9,
            0xa9e0,
            0xa9fe,
            0xaa00,
            0xaa36,
            0xaa40,
            0xaa4d,
            0xaa50,
            0xaa59,
            0xaa60,
            0xaa76,
            0xaa7a,
            0xaac2,
            0xaadb,
            0xaadd,
            0xaae0,
            0xaaef,
            0xaaf2,
            0xaaf6,
            0xab01,
            0xab06,
            0xab09,
            0xab0e,
            0xab11,
            0xab16,
            0xab20,
            0xab26,
            0xab28,
            0xab2e,
            0xab30,
            0xab5a,
            0xab5c,
            0xab69,
            0xab70,
            0xabea,
            0xabec,
            0xabed,
            0xabf0,
            0xabf9,
            0xac00,
            0xd7a3,
            0xd7b0,
            0xd7c6,
            0xd7cb,
            0xd7fb,
            0xf900,
            0xfa6d,
            0xfa70,
            0xfad9,
            0xfb00,
            0xfb06,
            0xfb13,
            0xfb17,
            0xfb1d,
            0xfb28,
            0xfb2a,
            0xfb36,
            0xfb38,
            0xfb3c,
            0xfb3e,
            0xfb3e,
            0xfb40,
            0xfb41,
            0xfb43,
            0xfb44,
            0xfb46,
            0xfbb1,
            0xfbd3,
            0xfc5d,
            0xfc64,
            0xfd3d,
            0xfd50,
            0xfd8f,
            0xfd92,
            0xfdc7,
            0xfdf0,
            0xfdf9,
            0xfe00,
            0xfe0f,
            0xfe20,
            0xfe2f,
            0xfe33,
            0xfe34,
            0xfe4d,
            0xfe4f,
            0xfe71,
            0xfe71,
            0xfe73,
            0xfe73,
            0xfe77,
            0xfe77,
            0xfe79,
            0xfe79,
            0xfe7b,
            0xfe7b,
            0xfe7d,
            0xfe7d,
            0xfe7f,
            0xfefc,
            0xff10,
            0xff19,
            0xff21,
            0xff3a,
            0xff3f,
            0xff3f,
            0xff41,
            0xff5a,
            0xff66,
            0xffbe,
            0xffc2,
            0xffc7,
            0xffca,
            0xffcf,
            0xffd2,
            0xffd7,
            0xffda,
            0xffdc,
            0x10000,
            0x1000b,
            0x1000d,
            0x10026,
            0x10028,
            0x1003a,
            0x1003c,
            0x1003d,
            0x1003f,
            0x1004d,
            0x10050,
            0x1005d,
            0x10080,
            0x100fa,
            0x10140,
            0x10174,
            0x101fd,
            0x101fd,
            0x10280,
            0x1029c,
            0x102a0,
            0x102d0,
            0x102e0,
            0x102e0,
            0x10300,
            0x1031f,
            0x1032d,
            0x1034a,
            0x10350,
            0x1037a,
            0x10380,
            0x1039d,
            0x103a0,
            0x103c3,
            0x103c8,
            0x103cf,
            0x103d1,
            0x103d5,
            0x10400,
            0x1049d,
            0x104a0,
            0x104a9,
            0x104b0,
            0x104d3,
            0x104d8,
            0x104fb,
            0x10500,
            0x10527,
            0x10530,
            0x10563,
            0x10600,
            0x10736,
            0x10740,
            0x10755,
            0x10760,
            0x10767,
            0x10800,
            0x10805,
            0x10808,
            0x10808,
            0x1080a,
            0x10835,
            0x10837,
            0x10838,
            0x1083c,
            0x1083c,
            0x1083f,
            0x10855,
            0x10860,
            0x10876,
            0x10880,
            0x1089e,
            0x108e0,
            0x108f2,
            0x108f4,
            0x108f5,
            0x10900,
            0x10915,
            0x10920,
            0x10939,
            0x10980,
            0x109b7,
            0x109be,
            0x109bf,
            0x10a00,
            0x10a03,
            0x10a05,
            0x10a06,
            0x10a0c,
            0x10a13,
            0x10a15,
            0x10a17,
            0x10a19,
            0x10a35,
            0x10a38,
            0x10a3a,
            0x10a3f,
            0x10a3f,
            0x10a60,
            0x10a7c,
            0x10a80,
            0x10a9c,
            0x10ac0,
            0x10ac7,
            0x10ac9,
            0x10ae6,
            0x10b00,
            0x10b35,
            0x10b40,
            0x10b55,
            0x10b60,
            0x10b72,
            0x10b80,
            0x10b91,
            0x10c00,
            0x10c48,
            0x10c80,
            0x10cb2,
            0x10cc0,
            0x10cf2,
            0x10d00,
            0x10d27,
            0x10d30,
            0x10d39,
            0x10e80,
            0x10ea9,
            0x10eab,
            0x10eac,
            0x10eb0,
            0x10eb1,
            0x10f00,
            0x10f1c,
            0x10f27,
            0x10f27,
            0x10f30,
            0x10f50,
            0x10fb0,
            0x10fc4,
            0x10fe0,
            0x10ff6,
            0x11000,
            0x11046,
            0x11066,
            0x1106f,
            0x1107f,
            0x110ba,
            0x110d0,
            0x110e8,
            0x110f0,
            0x110f9,
            0x11100,
            0x11134,
            0x11136,
            0x1113f,
            0x11144,
            0x11147,
            0x11150,
            0x11173,
            0x11176,
            0x11176,
            0x11180,
            0x111c4,
            0x111c9,
            0x111cc,
            0x111ce,
            0x111da,
            0x111dc,
            0x111dc,
            0x11200,
            0x11211,
            0x11213,
            0x11237,
            0x1123e,
            0x1123e,
            0x11280,
            0x11286,
            0x11288,
            0x11288,
            0x1128a,
            0x1128d,
            0x1128f,
            0x1129d,
            0x1129f,
            0x112a8,
            0x112b0,
            0x112ea,
            0x112f0,
            0x112f9,
            0x11300,
            0x11303,
            0x11305,
            0x1130c,
            0x1130f,
            0x11310,
            0x11313,
            0x11328,
            0x1132a,
            0x11330,
            0x11332,
            0x11333,
            0x11335,
            0x11339,
            0x1133b,
            0x11344,
            0x11347,
            0x11348,
            0x1134b,
            0x1134d,
            0x11350,
            0x11350,
            0x11357,
            0x11357,
            0x1135d,
            0x11363,
            0x11366,
            0x1136c,
            0x11370,
            0x11374,
            0x11400,
            0x1144a,
            0x11450,
            0x11459,
            0x1145e,
            0x11461,
            0x11480,
            0x114c5,
            0x114c7,
            0x114c7,
            0x114d0,
            0x114d9,
            0x11580,
            0x115b5,
            0x115b8,
            0x115c0,
            0x115d8,
            0x115dd,
            0x11600,
            0x11640,
            0x11644,
            0x11644,
            0x11650,
            0x11659,
            0x11680,
            0x116b8,
            0x116c0,
            0x116c9,
            0x11700,
            0x1171a,
            0x1171d,
            0x1172b,
            0x11730,
            0x11739,
            0x11800,
            0x1183a,
            0x118a0,
            0x118e9,
            0x118ff,
            0x11906,
            0x11909,
            0x11909,
            0x1190c,
            0x11913,
            0x11915,
            0x11916,
            0x11918,
            0x11935,
            0x11937,
            0x11938,
            0x1193b,
            0x11943,
            0x11950,
            0x11959,
            0x119a0,
            0x119a7,
            0x119aa,
            0x119d7,
            0x119da,
            0x119e1,
            0x119e3,
            0x119e4,
            0x11a00,
            0x11a3e,
            0x11a47,
            0x11a47,
            0x11a50,
            0x11a99,
            0x11a9d,
            0x11a9d,
            0x11ac0,
            0x11af8,
            0x11c00,
            0x11c08,
            0x11c0a,
            0x11c36,
            0x11c38,
            0x11c40,
            0x11c50,
            0x11c59,
            0x11c72,
            0x11c8f,
            0x11c92,
            0x11ca7,
            0x11ca9,
            0x11cb6,
            0x11d00,
            0x11d06,
            0x11d08,
            0x11d09,
            0x11d0b,
            0x11d36,
            0x11d3a,
            0x11d3a,
            0x11d3c,
            0x11d3d,
            0x11d3f,
            0x11d47,
            0x11d50,
            0x11d59,
            0x11d60,
            0x11d65,
            0x11d67,
            0x11d68,
            0x11d6a,
            0x11d8e,
            0x11d90,
            0x11d91,
            0x11d93,
            0x11d98,
            0x11da0,
            0x11da9,
            0x11ee0,
            0x11ef6,
            0x11fb0,
            0x11fb0,
            0x12000,
            0x12399,
            0x12400,
            0x1246e,
            0x12480,
            0x12543,
            0x13000,
            0x1342e,
            0x14400,
            0x14646,
            0x16800,
            0x16a38,
            0x16a40,
            0x16a5e,
            0x16a60,
            0x16a69,
            0x16ad0,
            0x16aed,
            0x16af0,
            0x16af4,
            0x16b00,
            0x16b36,
            0x16b40,
            0x16b43,
            0x16b50,
            0x16b59,
            0x16b63,
            0x16b77,
            0x16b7d,
            0x16b8f,
            0x16e40,
            0x16e7f,
            0x16f00,
            0x16f4a,
            0x16f4f,
            0x16f87,
            0x16f8f,
            0x16f9f,
            0x16fe0,
            0x16fe1,
            0x16fe3,
            0x16fe4,
            0x16ff0,
            0x16ff1,
            0x17000,
            0x187f7,
            0x18800,
            0x18cd5,
            0x18d00,
            0x18d08,
            0x1b000,
            0x1b11e,
            0x1b150,
            0x1b152,
            0x1b164,
            0x1b167,
            0x1b170,
            0x1b2fb,
            0x1bc00,
            0x1bc6a,
            0x1bc70,
            0x1bc7c,
            0x1bc80,
            0x1bc88,
            0x1bc90,
            0x1bc99,
            0x1bc9d,
            0x1bc9e,
            0x1d165,
            0x1d169,
            0x1d16d,
            0x1d172,
            0x1d17b,
            0x1d182,
            0x1d185,
            0x1d18b,
            0x1d1aa,
            0x1d1ad,
            0x1d242,
            0x1d244,
            0x1d400,
            0x1d454,
            0x1d456,
            0x1d49c,
            0x1d49e,
            0x1d49f,
            0x1d4a2,
            0x1d4a2,
            0x1d4a5,
            0x1d4a6,
            0x1d4a9,
            0x1d4ac,
            0x1d4ae,
            0x1d4b9,
            0x1d4bb,
            0x1d4bb,
            0x1d4bd,
            0x1d4c3,
            0x1d4c5,
            0x1d505,
            0x1d507,
            0x1d50a,
            0x1d50d,
            0x1d514,
            0x1d516,
            0x1d51c,
            0x1d51e,
            0x1d539,
            0x1d53b,
            0x1d53e,
            0x1d540,
            0x1d544,
            0x1d546,
            0x1d546,
            0x1d54a,
            0x1d550,
            0x1d552,
            0x1d6a5,
            0x1d6a8,
            0x1d6c0,
            0x1d6c2,
            0x1d6da,
            0x1d6dc,
            0x1d6fa,
            0x1d6fc,
            0x1d714,
            0x1d716,
            0x1d734,
            0x1d736,
            0x1d74e,
            0x1d750,
            0x1d76e,
            0x1d770,
            0x1d788,
            0x1d78a,
            0x1d7a8,
            0x1d7aa,
            0x1d7c2,
            0x1d7c4,
            0x1d7cb,
            0x1d7ce,
            0x1d7ff,
            0x1da00,
            0x1da36,
            0x1da3b,
            0x1da6c,
            0x1da75,
            0x1da75,
            0x1da84,
            0x1da84,
            0x1da9b,
            0x1da9f,
            0x1daa1,
            0x1daaf,
            0x1e000,
            0x1e006,
            0x1e008,
            0x1e018,
            0x1e01b,
            0x1e021,
            0x1e023,
            0x1e024,
            0x1e026,
            0x1e02a,
            0x1e100,
            0x1e12c,
            0x1e130,
            0x1e13d,
            0x1e140,
            0x1e149,
            0x1e14e,
            0x1e14e,
            0x1e2c0,
            0x1e2f9,
            0x1e800,
            0x1e8c4,
            0x1e8d0,
            0x1e8d6,
            0x1e900,
            0x1e94b,
            0x1e950,
            0x1e959,
            0x1ee00,
            0x1ee03,
            0x1ee05,
            0x1ee1f,
            0x1ee21,
            0x1ee22,
            0x1ee24,
            0x1ee24,
            0x1ee27,
            0x1ee27,
            0x1ee29,
            0x1ee32,
            0x1ee34,
            0x1ee37,
            0x1ee39,
            0x1ee39,
            0x1ee3b,
            0x1ee3b,
            0x1ee42,
            0x1ee42,
            0x1ee47,
            0x1ee47,
            0x1ee49,
            0x1ee49,
            0x1ee4b,
            0x1ee4b,
            0x1ee4d,
            0x1ee4f,
            0x1ee51,
            0x1ee52,
            0x1ee54,
            0x1ee54,
            0x1ee57,
            0x1ee57,
            0x1ee59,
            0x1ee59,
            0x1ee5b,
            0x1ee5b,
            0x1ee5d,
            0x1ee5d,
            0x1ee5f,
            0x1ee5f,
            0x1ee61,
            0x1ee62,
            0x1ee64,
            0x1ee64,
            0x1ee67,
            0x1ee6a,
            0x1ee6c,
            0x1ee72,
            0x1ee74,
            0x1ee77,
            0x1ee79,
            0x1ee7c,
            0x1ee7e,
            0x1ee7e,
            0x1ee80,
            0x1ee89,
            0x1ee8b,
            0x1ee9b,
            0x1eea1,
            0x1eea3,
            0x1eea5,
            0x1eea9,
            0x1eeab,
            0x1eebb,
            0x1fbf0,
            0x1fbf9,
            0x20000,
            0x2a6dd,
            0x2a700,
            0x2b734,
            0x2b740,
            0x2b81d,
            0x2b820,
            0x2cea1,
            0x2ceb0,
            0x2ebe0,
            0x2f800,
            0x2fa1d,
            0x30000,
            0x3134a,
            0xe0100,
            0xe01ef
        };

        private static TokenType? NFA_PYTHON_224(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (((ch >= '0' && ch <= '9' ) || ((ch >= 'A' && ch <= 'Z' ) || ((ch == '_') || (ch >= 'a' && ch <= 'z' )))) || ((ch >= (char) 128) && CheckIntervals(NFA_MOVES_PYTHON_224, ch))) {
                nextStates.Set(224);
                if (validTypes.Contains(TokenType.NAME)) {
                    return TokenType.NAME;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_225(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                if (validTypes.Contains(TokenType.IF)) {
                    return TokenType.IF;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_226(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(130);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_227(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_228(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(132);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_229(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(211);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_230(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'p') {
                nextStates.Set(150);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_231(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(207);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_232(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '<') {
                nextStates.Set(448);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_233(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_234(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                if (validTypes.Contains(TokenType.FOR)) {
                    return TokenType.FOR;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_235(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(430);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_236(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                nextStates.Set(220);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_237(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                if (validTypes.Contains(TokenType.LAMBDA)) {
                    return TokenType.LAMBDA;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_238(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_239(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_240(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(204);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_241(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '/') {
                nextStates.Set(208);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_242(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'x') {
                nextStates.Set(449);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_243(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(370);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_244(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'h') {
                if (validTypes.Contains(TokenType.MATCH)) {
                    return TokenType.MATCH;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_245(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'd') {
                if (validTypes.Contains(TokenType.YIELD)) {
                    return TokenType.YIELD;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_246(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(214);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_247(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(131);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_248(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '^') {
                nextStates.Set(295);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_249(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.NE)) {
                    return TokenType.NE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_250(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '%') {
                nextStates.Set(275);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_251(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_252(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                if (validTypes.Contains(TokenType.OR)) {
                    return TokenType.OR;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_253(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                if (validTypes.Contains(TokenType.RETURN)) {
                    return TokenType.RETURN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_254(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(40);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_255(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_256(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.CASE)) {
                    return TokenType.CASE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_257(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.FALSE)) {
                    return TokenType.FALSE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_258(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_259(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(368);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_260(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(360);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_261(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '>') {
                nextStates.Set(177);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_262(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_263(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(412);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_264(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(405);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_265(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_266(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.SLASHSLASHASSIGN)) {
                    return TokenType.SLASHSLASHASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_267(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                if (validTypes.Contains(TokenType.DOT)) {
                    return TokenType.DOT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_268(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(429);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_269(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(163);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_270(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(67);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_271(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'O') || (ch == 'o')) {
                nextStates.Set(65);
                if (validTypes.Contains(TokenType.OCTNUMBER)) {
                    return TokenType.OCTNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_272(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '~') {
                if (validTypes.Contains(TokenType.TILDE)) {
                    return TokenType.TILDE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_273(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(308);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_274(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_275(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.REMASSIGN)) {
                    return TokenType.REMASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_276(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(395);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_277(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_278(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(203);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_279(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.RAISE)) {
                    return TokenType.RAISE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_280(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch >= 'A' && ch <= 'Z' ) || ((ch == '_') || ((ch >= 'a' && ch <= 'z' ) || (ch >= 0x80 && ch <= 0xffff )))) {
                nextStates.Set(329);
                if (validTypes.Contains(TokenType.BADNAME)) {
                    return TokenType.BADNAME;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_281(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(454);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_282(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'p') {
                nextStates.Set(319);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_283(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_284(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(443);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_285(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                if (validTypes.Contains(TokenType.NONLOCAL)) {
                    return TokenType.NONLOCAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_286(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(276);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_287(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(446);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_288(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ' ') {
                if (validTypes.Contains(TokenType.HOOK)) {
                    return TokenType.HOOK;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_289(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'w') {
                nextStates.Set(318);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_290(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '*') {
                nextStates.Set(199);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_291(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x10ffff ) {
                nextStates.Set(97);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_292(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(110);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_293(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '<') {
                nextStates.Set(438);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_294(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'y') {
                if (validTypes.Contains(TokenType.FINALLY)) {
                    return TokenType.FINALLY;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_295(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.XORASSIGN)) {
                    return TokenType.XORASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_296(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_297(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x10ffff ) {
                nextStates.Set(24);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_298(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(404);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_299(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(285);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_300(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(304);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_301(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'w') {
                nextStates.Set(109);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_302(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '-') {
                if (validTypes.Contains(TokenType.MINUS)) {
                    return TokenType.MINUS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_303(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(185);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_304(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'c') {
                nextStates.Set(299);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_305(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'y') {
                if (validTypes.Contains(TokenType.TRY)) {
                    return TokenType.TRY;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_306(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(238);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_307(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(344);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_308(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(356);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_309(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'd') {
                nextStates.Set(237);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_310(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_311(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ']') {
                if (validTypes.Contains(TokenType.RBRACKET)) {
                    return TokenType.RBRACKET;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_312(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ':') {
                if (validTypes.Contains(TokenType.COLON)) {
                    return TokenType.COLON;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_313(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.WHILE)) {
                    return TokenType.WHILE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_314(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '*') {
                nextStates.Set(196);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_315(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(200);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_316(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(221);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_317(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(336);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_318(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(236);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_319(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(377);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_320(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(242);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_321(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_322(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_323(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '<') {
                if (validTypes.Contains(TokenType.LT)) {
                    return TokenType.LT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_324(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                if (validTypes.Contains(TokenType.AWAIT)) {
                    return TokenType.AWAIT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_325(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(260);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_326(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '^') {
                if (validTypes.Contains(TokenType.XOR)) {
                    return TokenType.XOR;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_327(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                nextStates.Set(450);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_328(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_329(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch >= '0' && ch <= '9' ) || ((ch >= 'A' && ch <= 'Z' ) || ((ch == '_') || ((ch >= 'a' && ch <= 'z' ) || (ch >= 0x80 && ch <= 0xffff ))))) {
                nextStates.Set(329);
                if (validTypes.Contains(TokenType.BADNAME)) {
                    return TokenType.BADNAME;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_330(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '/') {
                nextStates.Set(378);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_331(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_332(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(210);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_333(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'd') {
                nextStates.Set(425);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_334(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(325);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_335(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_336(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(324);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_337(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_338(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(183);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_339(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.RSHIFTASSIGN)) {
                    return TokenType.RSHIFTASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_340(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(287);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_341(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.ASSIGN)) {
                    return TokenType.ASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_342(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_343(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x7f ) {
                nextStates.Set(37);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_344(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(313);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_345(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '+') {
                if (validTypes.Contains(TokenType.PLUS)) {
                    return TokenType.PLUS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_346(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '/') {
                nextStates.Set(359);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_347(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(216);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_348(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(253);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_349(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_350(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(37);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_351(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(284);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_352(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(29);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_353(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(269);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_354(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x10ffff ) {
                nextStates.Set(68);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_355(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '*') {
                nextStates.Set(290);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_356(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(159);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_357(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(305);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_358(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '+') {
                nextStates.Set(173);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_359(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '/') {
                nextStates.Set(266);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_360(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'm') {
                if (validTypes.Contains(TokenType.FROM)) {
                    return TokenType.FROM;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_361(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(419);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_362(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '*') {
                if (validTypes.Contains(TokenType.STAR)) {
                    return TokenType.STAR;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_363(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_364(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(365);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_365(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(374);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_366(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(145);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_367(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(186);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_368(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(387);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_369(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'g') {
                nextStates.Set(303);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_370(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_371(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                nextStates.Set(410);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_372(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x7f ) {
                nextStates.Set(77);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_373(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_374(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(181);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_375(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_376(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'o') {
                nextStates.Set(252);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_377(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(175);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_378(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '/') {
                if (validTypes.Contains(TokenType._TOKEN_100)) {
                    return TokenType._TOKEN_100;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_379(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_380(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '|') {
                nextStates.Set(205);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_381(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(209);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_382(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '&') {
                if (validTypes.Contains(TokenType.BIT_AND)) {
                    return TokenType.BIT_AND;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_383(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(113);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_384(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'T') {
                nextStates.Set(192);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_385(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(240);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_386(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_387(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(143);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_388(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.Set(403);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_389(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(226);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_390(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_391(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '{') {
                if (validTypes.Contains(TokenType.LBRACE)) {
                    return TokenType.LBRACE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_392(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(146);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_393(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                if (validTypes.Contains(TokenType.DEF)) {
                    return TokenType.DEF;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_394(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                nextStates.Set(202);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_395(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                if (validTypes.Contains(TokenType.IMPORT)) {
                    return TokenType.IMPORT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_396(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_397(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.MINUSASSIGN)) {
                    return TokenType.MINUSASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_398(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                if (validTypes.Contains(TokenType.CONTINUE)) {
                    return TokenType.CONTINUE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_399(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '/') {
                if (validTypes.Contains(TokenType.SLASH)) {
                    return TokenType.SLASH;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_400(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(379);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_401(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '>') {
                nextStates.Set(108);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_402(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_403(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'X') || (ch == 'x')) {
                nextStates.Set(30);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_404(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'm') {
                nextStates.Set(134);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_405(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(24);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_406(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_407(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(230);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_408(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_409(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(366);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_410(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'c') {
                nextStates.Set(244);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_411(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '>') {
                nextStates.Set(190);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_412(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(257);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_413(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(371);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_414(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.Set(218);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_415(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '\t' ) || (ch >= 0xb)) {
                nextStates.Set(415);
                if (validTypes.Contains(TokenType.COMMENT)) {
                    return TokenType.COMMENT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_416(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_417(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.LSHIFTASSIGN)) {
                    return TokenType.LSHIFTASSIGN;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_418(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'd') {
                if (validTypes.Contains(TokenType.AND)) {
                    return TokenType.AND;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_419(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                if (validTypes.Contains(TokenType.AS)) {
                    return TokenType.AS;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_420(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(350);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_421(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_422(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_423(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_424(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_425(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(117);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_426(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(120);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_427(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'p') {
                nextStates.Set(128);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_428(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'N') {
                nextStates.Set(235);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_429(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'm') {
                nextStates.Set(215);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_430(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'n') {
                nextStates.Set(135);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_431(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_432(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ':') {
                nextStates.Set(138);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_433(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ',') {
                if (validTypes.Contains(TokenType.COMMA)) {
                    return TokenType.COMMA;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_434(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_435(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ';') {
                if (validTypes.Contains(TokenType.SEMICOLON)) {
                    return TokenType.SEMICOLON;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_436(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.Set(184);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_437(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(182);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_438(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '<') {
                nextStates.Set(417);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_439(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_440(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 't') {
                nextStates.Set(357);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_441(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'e') {
                nextStates.Set(427);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_442(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_443(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(112);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_444(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x7f ) {
                nextStates.Set(67);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_445(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_446(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(245);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_447(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch <= 0x10ffff ) {
                nextStates.Set(74);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_448(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '=') {
                if (validTypes.Contains(TokenType.LE)) {
                    return TokenType.LE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_449(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'c') {
                nextStates.Set(441);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_450(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(426);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_451(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_452(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_453(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_454(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'c') {
                if (validTypes.Contains(TokenType.ASYNC)) {
                    return TokenType.ASYNC;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_455(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.Set(165);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_456(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_457(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_458(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_459(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '!') {
                nextStates.Set(249);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_460(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'i') {
                nextStates.Set(225);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_461(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(18);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_462(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.Set(127);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_463(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(277);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_464(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(265);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_465(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(451);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_466(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.HEXNUMBER)) {
                    return TokenType.HEXNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_467(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(63);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_468(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(431);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_469(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_470(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(81);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_471(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(306);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_472(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(170);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_473(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(476);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_474(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(70);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_475(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'J') || (ch == 'j')) {
                if (validTypes.Contains(TokenType.COMPLEX)) {
                    return TokenType.COMPLEX;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_476(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(48);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_477(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    return TokenType.BINNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_478(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(40);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_479(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_480(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(103);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_481(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_482(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.Set(482);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    return TokenType.DECNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_483(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'U') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_484(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_485(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(452);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_486(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(599);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_487(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(328);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_488(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.Set(45);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_489(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(243);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_490(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_491(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(264);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_492(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(568);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_493(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(424);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_494(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(331);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_495(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '7' ) {
                nextStates.Set(65);
                if (validTypes.Contains(TokenType.OCTNUMBER)) {
                    return TokenType.OCTNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_496(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(648);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_497(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '!' ) || ((ch >= '#' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(74);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_498(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(96);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_499(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(560);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_500(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(54);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_501(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_502(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(180);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_503(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(658);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_504(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(187);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_505(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.Set(44);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_506(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(595);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_507(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(89);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_508(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(61);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_509(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(94);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_510(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_511(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(149);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_512(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '!' ) || ((ch >= '#' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(67);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_513(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(310);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_514(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_515(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(57);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_516(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_517(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(189);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_518(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(116);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_519(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(54);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_520(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(191);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_521(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(164);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_522(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(62);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_523(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(434);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_524(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.Set(90);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_525(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(663);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_526(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(223);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_527(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(104);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_528(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(198);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_529(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(408);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_530(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.Set(33);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_531(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_532(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '1' && ch <= '9' ) {
                nextStates.Set(31);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    return TokenType.DECNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_533(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(683);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_534(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(406);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_535(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(255);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_536(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '0' || ch == '1') {
                nextStates.Set(28);
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    return TokenType.BINNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_537(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(396);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_538(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(634);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_539(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(92);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_540(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(47);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_541(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(39);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_542(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(141);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_543(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(171);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_544(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(148);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_545(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(274);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_546(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(258);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_547(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(251);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_548(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(458);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_549(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(1);
                if (validTypes.Contains(TokenType.BADDECNUMBER)) {
                    return TokenType.BADDECNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_550(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(456);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_551(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(2);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_552(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(570);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_553(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(262);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_554(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(386);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_555(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(423);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_556(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(233);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_557(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(89);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_558(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(107);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_559(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(390);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_560(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(62);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_561(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(37);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_562(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(51);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_563(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'L') || (ch == 'l')) {
                nextStates.Set(475);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_564(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_565(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ' ') {
                nextStates.Set(19);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_566(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(162);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_567(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(416);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_568(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(96);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_569(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_570(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(61);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_571(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_572(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_573(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(73);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_574(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(444);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_575(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(156);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_576(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'U') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_577(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(82);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_578(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(239);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_579(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(478);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_580(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(83);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_581(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(88);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_582(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(97);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_583(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(296);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_584(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.OCTNUMBER)) {
                    return TokenType.OCTNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_585(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '&' ) || (ch >= '(')) {
                nextStates.Set(24);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_586(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(519);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_587(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '&' ) || ((ch >= '(' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(68);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_588(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(375);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_589(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(75);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_590(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(22);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_591(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(581);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_592(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'B') || (ch == 'b')) {
                nextStates.Set(28);
                if (validTypes.Contains(TokenType.BINNUMBER)) {
                    return TokenType.BINNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_593(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'L') || (ch == 'l')) {
                nextStates.Set(475);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_594(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(297);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_595(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(73);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_596(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'U') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_597(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(536);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_598(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\f') {
                nextStates.Set(49);
                if (validTypes.Contains(TokenType.SPACE)) {
                    return TokenType.SPACE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_599(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(76);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_600(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(363);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_601(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(666);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_602(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_603(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(650);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_604(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(372);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_605(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(402);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_606(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(102);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_607(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_608(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_609(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_610(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'U') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_611(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(507);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_612(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_613(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(291);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_614(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.Set(254);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_615(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(421);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_616(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\n') {
                if (validTypes.Contains(TokenType.NEWLINE)) {
                    return TokenType.NEWLINE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_617(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(646);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_618(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(453);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_619(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '!' ) || (ch >= '#')) {
                nextStates.Set(59);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_620(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(342);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_621(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(400);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_622(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.Set(461);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_623(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(3);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_624(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(335);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_625(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_626(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(337);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_627(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(447);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_628(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(283);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_629(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(457);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_630(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_631(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(373);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_632(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(321);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_633(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(495);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_634(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(63);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_635(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(590);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_636(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(31);
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    return TokenType.DECNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_637(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == ' ') {
                nextStates.Set(49);
                if (validTypes.Contains(TokenType.SPACE)) {
                    return TokenType.SPACE;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_638(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\f') {
                nextStates.Set(19);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_639(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(137);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_640(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(74);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_641(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(657);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_642(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'E') || (ch == 'e')) {
                nextStates.Set(42);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_643(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                if (validTypes.Contains(TokenType.STRING_LITERAL)) {
                    return TokenType.STRING_LITERAL;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_644(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.Set(53);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_645(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(222);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_646(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch >= '0' && ch <= '9' ) || ((ch >= 'A' && ch <= 'F' ) || (ch >= 'a' && ch <= 'f' ))) {
                nextStates.Set(80);
                if (validTypes.Contains(TokenType.HEXNUMBER)) {
                    return TokenType.HEXNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_647(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(354);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_648(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(88);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_649(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(227);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_650(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(45);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_651(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(549);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_652(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(439);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_653(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(343);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_654(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(662);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_655(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_656(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(188);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_657(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(68);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_658(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(18);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_659(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.Set(48);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_660(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.BADDECNUMBER)) {
                    return TokenType.BADDECNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_661(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(270);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_662(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(83);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_663(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(22);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_664(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(322);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_665(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'F') {
                nextStates.Set(491);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_666(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(70);
                if (validTypes.Contains(TokenType.FLOAT)) {
                    return TokenType.FLOAT;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_667(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_668(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(474);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_669(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'b') {
                nextStates.Set(119);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_670(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'B') {
                nextStates.Set(349);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_671(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(640);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_672(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(580);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_673(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\\') {
                nextStates.Set(133);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_674(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == 'L') || (ch == 'l')) {
                if (validTypes.Contains(TokenType.DECNUMBER)) {
                    return TokenType.DECNUMBER;
                }
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_675(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(445);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_676(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch <= '\t' ) || ((ch >= 0xb && ch <= '&' ) || ((ch >= '(' && ch <= '[' ) || (ch >= ']')))) {
                nextStates.Set(77);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_677(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'R') {
                nextStates.Set(544);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_678(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.Set(498);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_679(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.Set(139);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_680(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '_') {
                nextStates.Set(636);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_681(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.Set(55);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_682(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch == 'f') {
                nextStates.Set(422);
            }
            return null;
        }

        private static TokenType? NFA_PYTHON_683(int ch, BitSet nextStates, HashSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9' ) {
                nextStates.Set(76);
            }
            return null;
        }


        private static void NFA_FUNCTIONS_PYTHONInit() {
            var f = new NfaFunction[] {
                NFA_COMPOSITE_PYTHON_0,
                NFA_COMPOSITE_PYTHON_1,
                NFA_COMPOSITE_PYTHON_2,
                NFA_COMPOSITE_PYTHON_3,
                NFA_COMPOSITE_PYTHON_4,
                NFA_COMPOSITE_PYTHON_5,
                NFA_COMPOSITE_PYTHON_6,
                NFA_COMPOSITE_PYTHON_7,
                NFA_COMPOSITE_PYTHON_8,
                NFA_COMPOSITE_PYTHON_9,
                NFA_COMPOSITE_PYTHON_10,
                NFA_COMPOSITE_PYTHON_11,
                NFA_COMPOSITE_PYTHON_12,
                NFA_COMPOSITE_PYTHON_13,
                NFA_COMPOSITE_PYTHON_14,
                NFA_COMPOSITE_PYTHON_15,
                NFA_COMPOSITE_PYTHON_16,
                NFA_COMPOSITE_PYTHON_17,
                NFA_COMPOSITE_PYTHON_18,
                NFA_COMPOSITE_PYTHON_19,
                NFA_COMPOSITE_PYTHON_20,
                NFA_COMPOSITE_PYTHON_21,
                NFA_COMPOSITE_PYTHON_22,
                NFA_COMPOSITE_PYTHON_23,
                NFA_COMPOSITE_PYTHON_24,
                NFA_COMPOSITE_PYTHON_25,
                NFA_COMPOSITE_PYTHON_26,
                NFA_COMPOSITE_PYTHON_27,
                NFA_COMPOSITE_PYTHON_28,
                NFA_COMPOSITE_PYTHON_29,
                NFA_COMPOSITE_PYTHON_30,
                NFA_COMPOSITE_PYTHON_31,
                NFA_COMPOSITE_PYTHON_32,
                NFA_COMPOSITE_PYTHON_33,
                NFA_COMPOSITE_PYTHON_34,
                NFA_COMPOSITE_PYTHON_35,
                NFA_COMPOSITE_PYTHON_36,
                NFA_COMPOSITE_PYTHON_37,
                NFA_COMPOSITE_PYTHON_38,
                NFA_COMPOSITE_PYTHON_39,
                NFA_COMPOSITE_PYTHON_40,
                NFA_COMPOSITE_PYTHON_41,
                NFA_COMPOSITE_PYTHON_42,
                NFA_COMPOSITE_PYTHON_43,
                NFA_COMPOSITE_PYTHON_44,
                NFA_COMPOSITE_PYTHON_45,
                NFA_COMPOSITE_PYTHON_46,
                NFA_COMPOSITE_PYTHON_47,
                NFA_COMPOSITE_PYTHON_48,
                NFA_COMPOSITE_PYTHON_49,
                NFA_COMPOSITE_PYTHON_50,
                NFA_COMPOSITE_PYTHON_51,
                NFA_COMPOSITE_PYTHON_52,
                NFA_COMPOSITE_PYTHON_53,
                NFA_COMPOSITE_PYTHON_54,
                NFA_COMPOSITE_PYTHON_55,
                NFA_COMPOSITE_PYTHON_56,
                NFA_COMPOSITE_PYTHON_57,
                NFA_COMPOSITE_PYTHON_58,
                NFA_COMPOSITE_PYTHON_59,
                NFA_COMPOSITE_PYTHON_60,
                NFA_COMPOSITE_PYTHON_61,
                NFA_COMPOSITE_PYTHON_62,
                NFA_COMPOSITE_PYTHON_63,
                NFA_COMPOSITE_PYTHON_64,
                NFA_COMPOSITE_PYTHON_65,
                NFA_COMPOSITE_PYTHON_66,
                NFA_COMPOSITE_PYTHON_67,
                NFA_COMPOSITE_PYTHON_68,
                NFA_COMPOSITE_PYTHON_69,
                NFA_COMPOSITE_PYTHON_70,
                NFA_COMPOSITE_PYTHON_71,
                NFA_COMPOSITE_PYTHON_72,
                NFA_COMPOSITE_PYTHON_73,
                NFA_COMPOSITE_PYTHON_74,
                NFA_COMPOSITE_PYTHON_75,
                NFA_COMPOSITE_PYTHON_76,
                NFA_COMPOSITE_PYTHON_77,
                NFA_COMPOSITE_PYTHON_78,
                NFA_COMPOSITE_PYTHON_79,
                NFA_COMPOSITE_PYTHON_80,
                NFA_COMPOSITE_PYTHON_81,
                NFA_COMPOSITE_PYTHON_82,
                NFA_COMPOSITE_PYTHON_83,
                NFA_COMPOSITE_PYTHON_84,
                NFA_COMPOSITE_PYTHON_85,
                NFA_COMPOSITE_PYTHON_86,
                NFA_COMPOSITE_PYTHON_87,
                NFA_COMPOSITE_PYTHON_88,
                NFA_COMPOSITE_PYTHON_89,
                NFA_COMPOSITE_PYTHON_90,
                NFA_COMPOSITE_PYTHON_91,
                NFA_COMPOSITE_PYTHON_92,
                NFA_COMPOSITE_PYTHON_93,
                NFA_COMPOSITE_PYTHON_94,
                NFA_COMPOSITE_PYTHON_95,
                NFA_COMPOSITE_PYTHON_96,
                NFA_COMPOSITE_PYTHON_97,
                NFA_COMPOSITE_PYTHON_98,
                NFA_PYTHON_99,
                NFA_PYTHON_100,
                NFA_PYTHON_101,
                NFA_PYTHON_102,
                NFA_PYTHON_103,
                NFA_PYTHON_104,
                NFA_PYTHON_105,
                NFA_PYTHON_106,
                NFA_PYTHON_107,
                NFA_PYTHON_108,
                NFA_PYTHON_109,
                NFA_PYTHON_110,
                NFA_PYTHON_111,
                NFA_PYTHON_112,
                NFA_PYTHON_113,
                NFA_PYTHON_114,
                NFA_PYTHON_115,
                NFA_PYTHON_116,
                NFA_PYTHON_117,
                NFA_PYTHON_118,
                NFA_PYTHON_119,
                NFA_PYTHON_120,
                NFA_PYTHON_121,
                NFA_PYTHON_122,
                NFA_PYTHON_123,
                NFA_PYTHON_124,
                NFA_PYTHON_125,
                NFA_PYTHON_126,
                NFA_PYTHON_127,
                NFA_PYTHON_128,
                NFA_PYTHON_129,
                NFA_PYTHON_130,
                NFA_PYTHON_131,
                NFA_PYTHON_132,
                NFA_PYTHON_133,
                NFA_PYTHON_134,
                NFA_PYTHON_135,
                NFA_PYTHON_136,
                NFA_PYTHON_137,
                NFA_PYTHON_138,
                NFA_PYTHON_139,
                NFA_PYTHON_140,
                NFA_PYTHON_141,
                NFA_PYTHON_142,
                NFA_PYTHON_143,
                NFA_PYTHON_144,
                NFA_PYTHON_145,
                NFA_PYTHON_146,
                NFA_PYTHON_147,
                NFA_PYTHON_148,
                NFA_PYTHON_149,
                NFA_PYTHON_150,
                NFA_PYTHON_151,
                NFA_PYTHON_152,
                NFA_PYTHON_153,
                NFA_PYTHON_154,
                NFA_PYTHON_155,
                NFA_PYTHON_156,
                NFA_PYTHON_157,
                NFA_PYTHON_158,
                NFA_PYTHON_159,
                NFA_PYTHON_160,
                NFA_PYTHON_161,
                NFA_PYTHON_162,
                NFA_PYTHON_163,
                NFA_PYTHON_164,
                NFA_PYTHON_165,
                NFA_PYTHON_166,
                NFA_PYTHON_167,
                NFA_PYTHON_168,
                NFA_PYTHON_169,
                NFA_PYTHON_170,
                NFA_PYTHON_171,
                NFA_PYTHON_172,
                NFA_PYTHON_173,
                NFA_PYTHON_174,
                NFA_PYTHON_175,
                NFA_PYTHON_176,
                NFA_PYTHON_177,
                NFA_PYTHON_178,
                NFA_PYTHON_179,
                NFA_PYTHON_180,
                NFA_PYTHON_181,
                NFA_PYTHON_182,
                NFA_PYTHON_183,
                NFA_PYTHON_184,
                NFA_PYTHON_185,
                NFA_PYTHON_186,
                NFA_PYTHON_187,
                NFA_PYTHON_188,
                NFA_PYTHON_189,
                NFA_PYTHON_190,
                NFA_PYTHON_191,
                NFA_PYTHON_192,
                NFA_PYTHON_193,
                NFA_PYTHON_194,
                NFA_PYTHON_195,
                NFA_PYTHON_196,
                NFA_PYTHON_197,
                NFA_PYTHON_198,
                NFA_PYTHON_199,
                NFA_PYTHON_200,
                NFA_PYTHON_201,
                NFA_PYTHON_202,
                NFA_PYTHON_203,
                NFA_PYTHON_204,
                NFA_PYTHON_205,
                NFA_PYTHON_206,
                NFA_PYTHON_207,
                NFA_PYTHON_208,
                NFA_PYTHON_209,
                NFA_PYTHON_210,
                NFA_PYTHON_211,
                NFA_PYTHON_212,
                NFA_PYTHON_213,
                NFA_PYTHON_214,
                NFA_PYTHON_215,
                NFA_PYTHON_216,
                NFA_PYTHON_217,
                NFA_PYTHON_218,
                NFA_PYTHON_219,
                NFA_PYTHON_220,
                NFA_PYTHON_221,
                NFA_PYTHON_222,
                NFA_PYTHON_223,
                NFA_PYTHON_224,
                NFA_PYTHON_225,
                NFA_PYTHON_226,
                NFA_PYTHON_227,
                NFA_PYTHON_228,
                NFA_PYTHON_229,
                NFA_PYTHON_230,
                NFA_PYTHON_231,
                NFA_PYTHON_232,
                NFA_PYTHON_233,
                NFA_PYTHON_234,
                NFA_PYTHON_235,
                NFA_PYTHON_236,
                NFA_PYTHON_237,
                NFA_PYTHON_238,
                NFA_PYTHON_239,
                NFA_PYTHON_240,
                NFA_PYTHON_241,
                NFA_PYTHON_242,
                NFA_PYTHON_243,
                NFA_PYTHON_244,
                NFA_PYTHON_245,
                NFA_PYTHON_246,
                NFA_PYTHON_247,
                NFA_PYTHON_248,
                NFA_PYTHON_249,
                NFA_PYTHON_250,
                NFA_PYTHON_251,
                NFA_PYTHON_252,
                NFA_PYTHON_253,
                NFA_PYTHON_254,
                NFA_PYTHON_255,
                NFA_PYTHON_256,
                NFA_PYTHON_257,
                NFA_PYTHON_258,
                NFA_PYTHON_259,
                NFA_PYTHON_260,
                NFA_PYTHON_261,
                NFA_PYTHON_262,
                NFA_PYTHON_263,
                NFA_PYTHON_264,
                NFA_PYTHON_265,
                NFA_PYTHON_266,
                NFA_PYTHON_267,
                NFA_PYTHON_268,
                NFA_PYTHON_269,
                NFA_PYTHON_270,
                NFA_PYTHON_271,
                NFA_PYTHON_272,
                NFA_PYTHON_273,
                NFA_PYTHON_274,
                NFA_PYTHON_275,
                NFA_PYTHON_276,
                NFA_PYTHON_277,
                NFA_PYTHON_278,
                NFA_PYTHON_279,
                NFA_PYTHON_280,
                NFA_PYTHON_281,
                NFA_PYTHON_282,
                NFA_PYTHON_283,
                NFA_PYTHON_284,
                NFA_PYTHON_285,
                NFA_PYTHON_286,
                NFA_PYTHON_287,
                NFA_PYTHON_288,
                NFA_PYTHON_289,
                NFA_PYTHON_290,
                NFA_PYTHON_291,
                NFA_PYTHON_292,
                NFA_PYTHON_293,
                NFA_PYTHON_294,
                NFA_PYTHON_295,
                NFA_PYTHON_296,
                NFA_PYTHON_297,
                NFA_PYTHON_298,
                NFA_PYTHON_299,
                NFA_PYTHON_300,
                NFA_PYTHON_301,
                NFA_PYTHON_302,
                NFA_PYTHON_303,
                NFA_PYTHON_304,
                NFA_PYTHON_305,
                NFA_PYTHON_306,
                NFA_PYTHON_307,
                NFA_PYTHON_308,
                NFA_PYTHON_309,
                NFA_PYTHON_310,
                NFA_PYTHON_311,
                NFA_PYTHON_312,
                NFA_PYTHON_313,
                NFA_PYTHON_314,
                NFA_PYTHON_315,
                NFA_PYTHON_316,
                NFA_PYTHON_317,
                NFA_PYTHON_318,
                NFA_PYTHON_319,
                NFA_PYTHON_320,
                NFA_PYTHON_321,
                NFA_PYTHON_322,
                NFA_PYTHON_323,
                NFA_PYTHON_324,
                NFA_PYTHON_325,
                NFA_PYTHON_326,
                NFA_PYTHON_327,
                NFA_PYTHON_328,
                NFA_PYTHON_329,
                NFA_PYTHON_330,
                NFA_PYTHON_331,
                NFA_PYTHON_332,
                NFA_PYTHON_333,
                NFA_PYTHON_334,
                NFA_PYTHON_335,
                NFA_PYTHON_336,
                NFA_PYTHON_337,
                NFA_PYTHON_338,
                NFA_PYTHON_339,
                NFA_PYTHON_340,
                NFA_PYTHON_341,
                NFA_PYTHON_342,
                NFA_PYTHON_343,
                NFA_PYTHON_344,
                NFA_PYTHON_345,
                NFA_PYTHON_346,
                NFA_PYTHON_347,
                NFA_PYTHON_348,
                NFA_PYTHON_349,
                NFA_PYTHON_350,
                NFA_PYTHON_351,
                NFA_PYTHON_352,
                NFA_PYTHON_353,
                NFA_PYTHON_354,
                NFA_PYTHON_355,
                NFA_PYTHON_356,
                NFA_PYTHON_357,
                NFA_PYTHON_358,
                NFA_PYTHON_359,
                NFA_PYTHON_360,
                NFA_PYTHON_361,
                NFA_PYTHON_362,
                NFA_PYTHON_363,
                NFA_PYTHON_364,
                NFA_PYTHON_365,
                NFA_PYTHON_366,
                NFA_PYTHON_367,
                NFA_PYTHON_368,
                NFA_PYTHON_369,
                NFA_PYTHON_370,
                NFA_PYTHON_371,
                NFA_PYTHON_372,
                NFA_PYTHON_373,
                NFA_PYTHON_374,
                NFA_PYTHON_375,
                NFA_PYTHON_376,
                NFA_PYTHON_377,
                NFA_PYTHON_378,
                NFA_PYTHON_379,
                NFA_PYTHON_380,
                NFA_PYTHON_381,
                NFA_PYTHON_382,
                NFA_PYTHON_383,
                NFA_PYTHON_384,
                NFA_PYTHON_385,
                NFA_PYTHON_386,
                NFA_PYTHON_387,
                NFA_PYTHON_388,
                NFA_PYTHON_389,
                NFA_PYTHON_390,
                NFA_PYTHON_391,
                NFA_PYTHON_392,
                NFA_PYTHON_393,
                NFA_PYTHON_394,
                NFA_PYTHON_395,
                NFA_PYTHON_396,
                NFA_PYTHON_397,
                NFA_PYTHON_398,
                NFA_PYTHON_399,
                NFA_PYTHON_400,
                NFA_PYTHON_401,
                NFA_PYTHON_402,
                NFA_PYTHON_403,
                NFA_PYTHON_404,
                NFA_PYTHON_405,
                NFA_PYTHON_406,
                NFA_PYTHON_407,
                NFA_PYTHON_408,
                NFA_PYTHON_409,
                NFA_PYTHON_410,
                NFA_PYTHON_411,
                NFA_PYTHON_412,
                NFA_PYTHON_413,
                NFA_PYTHON_414,
                NFA_PYTHON_415,
                NFA_PYTHON_416,
                NFA_PYTHON_417,
                NFA_PYTHON_418,
                NFA_PYTHON_419,
                NFA_PYTHON_420,
                NFA_PYTHON_421,
                NFA_PYTHON_422,
                NFA_PYTHON_423,
                NFA_PYTHON_424,
                NFA_PYTHON_425,
                NFA_PYTHON_426,
                NFA_PYTHON_427,
                NFA_PYTHON_428,
                NFA_PYTHON_429,
                NFA_PYTHON_430,
                NFA_PYTHON_431,
                NFA_PYTHON_432,
                NFA_PYTHON_433,
                NFA_PYTHON_434,
                NFA_PYTHON_435,
                NFA_PYTHON_436,
                NFA_PYTHON_437,
                NFA_PYTHON_438,
                NFA_PYTHON_439,
                NFA_PYTHON_440,
                NFA_PYTHON_441,
                NFA_PYTHON_442,
                NFA_PYTHON_443,
                NFA_PYTHON_444,
                NFA_PYTHON_445,
                NFA_PYTHON_446,
                NFA_PYTHON_447,
                NFA_PYTHON_448,
                NFA_PYTHON_449,
                NFA_PYTHON_450,
                NFA_PYTHON_451,
                NFA_PYTHON_452,
                NFA_PYTHON_453,
                NFA_PYTHON_454,
                NFA_PYTHON_455,
                NFA_PYTHON_456,
                NFA_PYTHON_457,
                NFA_PYTHON_458,
                NFA_PYTHON_459,
                NFA_PYTHON_460,
                NFA_PYTHON_461,
                NFA_PYTHON_462,
                NFA_PYTHON_463,
                NFA_PYTHON_464,
                NFA_PYTHON_465,
                NFA_PYTHON_466,
                NFA_PYTHON_467,
                NFA_PYTHON_468,
                NFA_PYTHON_469,
                NFA_PYTHON_470,
                NFA_PYTHON_471,
                NFA_PYTHON_472,
                NFA_PYTHON_473,
                NFA_PYTHON_474,
                NFA_PYTHON_475,
                NFA_PYTHON_476,
                NFA_PYTHON_477,
                NFA_PYTHON_478,
                NFA_PYTHON_479,
                NFA_PYTHON_480,
                NFA_PYTHON_481,
                NFA_PYTHON_482,
                NFA_PYTHON_483,
                NFA_PYTHON_484,
                NFA_PYTHON_485,
                NFA_PYTHON_486,
                NFA_PYTHON_487,
                NFA_PYTHON_488,
                NFA_PYTHON_489,
                NFA_PYTHON_490,
                NFA_PYTHON_491,
                NFA_PYTHON_492,
                NFA_PYTHON_493,
                NFA_PYTHON_494,
                NFA_PYTHON_495,
                NFA_PYTHON_496,
                NFA_PYTHON_497,
                NFA_PYTHON_498,
                NFA_PYTHON_499,
                NFA_PYTHON_500,
                NFA_PYTHON_501,
                NFA_PYTHON_502,
                NFA_PYTHON_503,
                NFA_PYTHON_504,
                NFA_PYTHON_505,
                NFA_PYTHON_506,
                NFA_PYTHON_507,
                NFA_PYTHON_508,
                NFA_PYTHON_509,
                NFA_PYTHON_510,
                NFA_PYTHON_511,
                NFA_PYTHON_512,
                NFA_PYTHON_513,
                NFA_PYTHON_514,
                NFA_PYTHON_515,
                NFA_PYTHON_516,
                NFA_PYTHON_517,
                NFA_PYTHON_518,
                NFA_PYTHON_519,
                NFA_PYTHON_520,
                NFA_PYTHON_521,
                NFA_PYTHON_522,
                NFA_PYTHON_523,
                NFA_PYTHON_524,
                NFA_PYTHON_525,
                NFA_PYTHON_526,
                NFA_PYTHON_527,
                NFA_PYTHON_528,
                NFA_PYTHON_529,
                NFA_PYTHON_530,
                NFA_PYTHON_531,
                NFA_PYTHON_532,
                NFA_PYTHON_533,
                NFA_PYTHON_534,
                NFA_PYTHON_535,
                NFA_PYTHON_536,
                NFA_PYTHON_537,
                NFA_PYTHON_538,
                NFA_PYTHON_539,
                NFA_PYTHON_540,
                NFA_PYTHON_541,
                NFA_PYTHON_542,
                NFA_PYTHON_543,
                NFA_PYTHON_544,
                NFA_PYTHON_545,
                NFA_PYTHON_546,
                NFA_PYTHON_547,
                NFA_PYTHON_548,
                NFA_PYTHON_549,
                NFA_PYTHON_550,
                NFA_PYTHON_551,
                NFA_PYTHON_552,
                NFA_PYTHON_553,
                NFA_PYTHON_554,
                NFA_PYTHON_555,
                NFA_PYTHON_556,
                NFA_PYTHON_557,
                NFA_PYTHON_558,
                NFA_PYTHON_559,
                NFA_PYTHON_560,
                NFA_PYTHON_561,
                NFA_PYTHON_562,
                NFA_PYTHON_563,
                NFA_PYTHON_564,
                NFA_PYTHON_565,
                NFA_PYTHON_566,
                NFA_PYTHON_567,
                NFA_PYTHON_568,
                NFA_PYTHON_569,
                NFA_PYTHON_570,
                NFA_PYTHON_571,
                NFA_PYTHON_572,
                NFA_PYTHON_573,
                NFA_PYTHON_574,
                NFA_PYTHON_575,
                NFA_PYTHON_576,
                NFA_PYTHON_577,
                NFA_PYTHON_578,
                NFA_PYTHON_579,
                NFA_PYTHON_580,
                NFA_PYTHON_581,
                NFA_PYTHON_582,
                NFA_PYTHON_583,
                NFA_PYTHON_584,
                NFA_PYTHON_585,
                NFA_PYTHON_586,
                NFA_PYTHON_587,
                NFA_PYTHON_588,
                NFA_PYTHON_589,
                NFA_PYTHON_590,
                NFA_PYTHON_591,
                NFA_PYTHON_592,
                NFA_PYTHON_593,
                NFA_PYTHON_594,
                NFA_PYTHON_595,
                NFA_PYTHON_596,
                NFA_PYTHON_597,
                NFA_PYTHON_598,
                NFA_PYTHON_599,
                NFA_PYTHON_600,
                NFA_PYTHON_601,
                NFA_PYTHON_602,
                NFA_PYTHON_603,
                NFA_PYTHON_604,
                NFA_PYTHON_605,
                NFA_PYTHON_606,
                NFA_PYTHON_607,
                NFA_PYTHON_608,
                NFA_PYTHON_609,
                NFA_PYTHON_610,
                NFA_PYTHON_611,
                NFA_PYTHON_612,
                NFA_PYTHON_613,
                NFA_PYTHON_614,
                NFA_PYTHON_615,
                NFA_PYTHON_616,
                NFA_PYTHON_617,
                NFA_PYTHON_618,
                NFA_PYTHON_619,
                NFA_PYTHON_620,
                NFA_PYTHON_621,
                NFA_PYTHON_622,
                NFA_PYTHON_623,
                NFA_PYTHON_624,
                NFA_PYTHON_625,
                NFA_PYTHON_626,
                NFA_PYTHON_627,
                NFA_PYTHON_628,
                NFA_PYTHON_629,
                NFA_PYTHON_630,
                NFA_PYTHON_631,
                NFA_PYTHON_632,
                NFA_PYTHON_633,
                NFA_PYTHON_634,
                NFA_PYTHON_635,
                NFA_PYTHON_636,
                NFA_PYTHON_637,
                NFA_PYTHON_638,
                NFA_PYTHON_639,
                NFA_PYTHON_640,
                NFA_PYTHON_641,
                NFA_PYTHON_642,
                NFA_PYTHON_643,
                NFA_PYTHON_644,
                NFA_PYTHON_645,
                NFA_PYTHON_646,
                NFA_PYTHON_647,
                NFA_PYTHON_648,
                NFA_PYTHON_649,
                NFA_PYTHON_650,
                NFA_PYTHON_651,
                NFA_PYTHON_652,
                NFA_PYTHON_653,
                NFA_PYTHON_654,
                NFA_PYTHON_655,
                NFA_PYTHON_656,
                NFA_PYTHON_657,
                NFA_PYTHON_658,
                NFA_PYTHON_659,
                NFA_PYTHON_660,
                NFA_PYTHON_661,
                NFA_PYTHON_662,
                NFA_PYTHON_663,
                NFA_PYTHON_664,
                NFA_PYTHON_665,
                NFA_PYTHON_666,
                NFA_PYTHON_667,
                NFA_PYTHON_668,
                NFA_PYTHON_669,
                NFA_PYTHON_670,
                NFA_PYTHON_671,
                NFA_PYTHON_672,
                NFA_PYTHON_673,
                NFA_PYTHON_674,
                NFA_PYTHON_675,
                NFA_PYTHON_676,
                NFA_PYTHON_677,
                NFA_PYTHON_678,
                NFA_PYTHON_679,
                NFA_PYTHON_680,
                NFA_PYTHON_681,
                NFA_PYTHON_682,
                NFA_PYTHON_683
            };
            nfaFunctions = f;
        }


            private const int MaxStates = 684;

        // The following two BitSets are used to store
        // the current active NFA states in the core tokenization loop
        private BitSet _nextStates = new BitSet(MaxStates), _currentStates = new BitSet(MaxStates);

        internal HashSet<TokenType> ActiveTokenTypes = Utils.EnumSet(
            TokenType.EOF,
            TokenType.SPACE,
            TokenType.CONTINUE_LINE,
            TokenType.COMMENT,
            TokenType.NEWLINE,
            TokenType.ASSIGN,
            TokenType.AT,
            TokenType.COLON,
            TokenType.COMMA,
            TokenType.EQ,
            TokenType.LBRACE,
            TokenType.RBRACE,
            TokenType.LBRACKET,
            TokenType.RBRACKET,
            TokenType.LPAREN,
            TokenType.RPAREN,
            TokenType.SEMICOLON,
            TokenType.STAR,
            TokenType.STAR_STAR,
            TokenType.MINUSASSIGN,
            TokenType.PLUSASSIGN,
            TokenType.STARASSIGN,
            TokenType.ATASSIGN,
            TokenType.SLASHASSIGN,
            TokenType.REMASSIGN,
            TokenType.ANDASSIGN,
            TokenType.ORASSIGN,
            TokenType.XORASSIGN,
            TokenType.LSHIFTASSIGN,
            TokenType.RSHIFTASSIGN,
            TokenType.STARSTARASSIGN,
            TokenType.SLASHSLASHASSIGN,
            TokenType.BIT_AND,
            TokenType.BIT_OR,
            TokenType.XOR,
            TokenType.TILDE,
            TokenType.COLONEQUALS,
            TokenType.DOT,
            TokenType.ELLIPSIS,
            TokenType.LE,
            TokenType.GE,
            TokenType.NE,
            TokenType.GT,
            TokenType.LT,
            TokenType.MINUS,
            TokenType.PLUS,
            TokenType.SLASH,
            TokenType.PERCENT,
            TokenType.LSHIFT,
            TokenType.RSHIFT,
            TokenType.HOOK,
            TokenType.RARROW,
            TokenType.AND,
            TokenType.AS,
            TokenType._ASSERT,
            TokenType.ASYNC,
            TokenType.AWAIT,
            TokenType.BREAK,
            TokenType.CASE,
            TokenType.CLASS,
            TokenType.CONTINUE,
            TokenType.DEF,
            TokenType.DEL,
            TokenType.EXCEPT,
            TokenType.FINALLY,
            TokenType.FOR,
            TokenType.FROM,
            TokenType.GLOBAL,
            TokenType.IF,
            TokenType.IN,
            TokenType.IS,
            TokenType.ELIF,
            TokenType.ELSE,
            TokenType.FALSE,
            TokenType.IMPORT,
            TokenType.LAMBDA,
            TokenType.MATCH,
            TokenType.NONLOCAL,
            TokenType.NONE,
            TokenType.NOT,
            TokenType.OR,
            TokenType.PASS,
            TokenType.PEG_PARSER,
            TokenType.RAISE,
            TokenType.RETURN,
            TokenType.TRUE,
            TokenType.TRY,
            TokenType.WHILE,
            TokenType.WITH,
            TokenType.YIELD,
            TokenType.DECNUMBER,
            TokenType.BADDECNUMBER,
            TokenType.HEXNUMBER,
            TokenType.OCTNUMBER,
            TokenType.BINNUMBER,
            TokenType.FLOAT,
            TokenType.COMPLEX,
            TokenType.STRING_LITERAL,
            TokenType.NAME,
            TokenType.BADNAME,
            TokenType._TOKEN_100
        );

        private LexicalState _lexicalState;
        private readonly int[] _lineOffsets;   // offsets to the beginnings of lines
        private readonly Token[] _tokenLocationTable;
        private int _bufferPosition;
        private readonly BitSet _tokenOffsets;

        public LexicalState LexicalState => _lexicalState;

        // constructors

        static Lexer() {
            NFA_FUNCTIONS_PYTHONInit();
            DummyStartToken = new InvalidToken(null, 0, 0);
            Ignored = new InvalidToken(null, 0, 0);
            Skipped = new InvalidToken(null, 0, 0);
            Ignored.IsUnparsed = true;
            Skipped.IsUnparsed = true;
        }


        public Lexer(string inputSource, LexicalState lexState = LexicalState.PYTHON, int line = 1, int column = 1) {
            InputSource = inputSource;
            var input = InputText(inputSource);
            _content = MungeContent(input, 8, false, false, true);
            _contentLength = _content.Length;
            _lineOffsets = CreateLineOffsetsTable(_content);
            _tokenLocationTable = new Token[_contentLength + 1];
            _tokenOffsets = new BitSet(_contentLength + 1);
            startingLine = line;
            startingColumn = column;
            ActiveTokenTypes.Remove(TokenType.MATCH);
            ActiveTokenTypes.Remove(TokenType.CASE);
            regularTokens.Add(TokenType.INDENT);
            regularTokens.Add(TokenType.DEDENT);
            SwitchTo(lexState);
        }

        private static readonly Regex PythonCodingPattern = new Regex(@"^[ \t\f]*#.*\bcoding[:=][ \t]*([-_.a-zA-Z0-9]+)");
        private static readonly UTF8Encoding Utf8 = new UTF8Encoding(true);
        private static readonly UnicodeEncoding Utf16Le = new UnicodeEncoding(false, true, true);
        private static readonly UnicodeEncoding Utf16Be = new UnicodeEncoding(true, true, true);
        private static readonly UTF32Encoding Utf32Le = new UTF32Encoding(false, true, true);
        private static readonly UTF32Encoding Utf32Be = new UTF32Encoding(true, true, true);

        private String InputText(string path) {
            var fs = new FileStream(path, FileMode.Open);
            var fileLen = (int) fs.Length;
            var bytes = new byte[fileLen];
            var bomLen = 3;
            Encoding encoding;
            var allBytes = new Span<byte>(bytes);
            Span<byte> bomBytes;
            Span<byte> foundBom = null;

            fs.Read(bytes, 0, fileLen);

            if (fileLen <= bomLen) {
                encoding = Utf8;
            }
            else if ((bomBytes = allBytes[..bomLen]) == Utf8.GetPreamble()) {
                encoding = Utf8;
                foundBom = bomBytes;
            }
            else if ((bomBytes = allBytes[..(bomLen = 2)]) == Utf16Le.GetPreamble()) {
                encoding = Utf16Le;
                foundBom = bomBytes;
            }
            else if (bomBytes == Utf16Be.GetPreamble()) {
                encoding = Utf16Be;
                foundBom = bomBytes;
            }
            else if ((bomBytes = allBytes[(bomLen = 4)..]) == Utf32Le.GetPreamble()) {
                encoding = Utf32Le;
                foundBom = bomBytes;
            }
            else if (bomBytes == Utf32Be.GetPreamble()) {
                encoding = Utf32Be;
                foundBom = bomBytes;
            }
            else {
                encoding = Utf8;
                if (path.EndsWith(".py")) {
                    // Look for coding declared in first two lines
                    var pos = System.Array.IndexOf(bytes, '\n');
                    if (pos > 0) {
                        var s = Utf8.GetString(allBytes.Slice(0, pos));
                        var m = PythonCodingPattern.Match(s);

                        if (m.Success) {
                            s = m.Groups[1].Value;
                            encoding = Encoding.GetEncoding(s);
                        }
                        else {
                            pos = System.Array.IndexOf(bytes, '\n', pos + 1);
                            if (pos > 0) {
                                s = Utf8.GetString(allBytes.Slice(0, pos));
                                m = PythonCodingPattern.Match(s);
                                if (m.Success) {
                                    s = m.Groups[1].Value;
                                    encoding = Encoding.GetEncoding(s);
                                }
                            }
                        }
                    }
                }
            }
            var rest = (foundBom == null) ? allBytes : allBytes[bomLen..];
            return encoding.GetString(rest);
        }

        private static readonly int[] EmptyInt = new int[] { 0 };

        private int[] CreateLineOffsetsTable(string content) {
            if (content.Length == 0) {
                return EmptyInt;
            }
            var lineCount = 0;
            var length = content.Length;
            for (var i = 0; i < length; i++) {
                var ch = content[i];
                if (ch == '\n') {
                    lineCount++;
                }
            }
            if (content[^1] != '\n') {
                lineCount++;
            }
            var lineOffsets = new int[lineCount];
            lineOffsets[0] = 0;
            var index = 1;
            for (var i = 0; i < length; i++) {
                var ch = content[i];
                if (ch != '\n') continue;
                if (i + 1 == length)
                    break;
                lineOffsets[index++] = i + 1;
            }
            return lineOffsets;
        }

        //
        // Switch to specified lexical state.
        //
        private bool SwitchTo(LexicalState lexState) {
            if (_lexicalState != lexState) {
                _lexicalState = lexState;
                return true;
            }
            return false;
        }


        private Token GetNextToken() {
            Token token;
            do {
                token = NextToken();
            } while (token is InvalidToken);
            if (_invalidToken != null) {
                _invalidToken.TokenSource = this;
                Token it = _invalidToken;
                _invalidToken = null;
                CacheToken(it);
                return it;
            }
            CacheToken(token);
            return token;
        }

        /**
        * The public method for getting the next token.
        * If the tok parameter is null, it just tokenizes 
        * starting at the internal _bufferPosition
        * Otherwise, it checks whether we have already cached
        * the token after this one. If not, it finally goes 
        * to the NFA machinery
        */ 
        public Token GetNextToken(Token tok) {
            if(tok == null) {
                return GetNextToken();
            }
            Token cachedToken = tok.NextCachedToken;
            // If the cached next token is not currently active, we
            // throw it away and go back to the lexer
            if (cachedToken != null && !ActiveTokenTypes.Contains(cachedToken.Type)) {
                Reset(tok);
                cachedToken = null;
            }
            return cachedToken != null ? cachedToken : GetNextToken(tok.EndOffset);
        }

        /**
        * A lower level method to tokenize, that takes the absolute
        * offset into the _content buffer as a parameter
        * @param offset where to start
        * @return the token that results from scanning from the given starting point 
        */
        public Token GetNextToken(int offset) {
            GoTo(offset);
            return GetNextToken();
        }

        // The main method to invoke the NFA machinery
        private Token NextToken() {
            Token matchedToken = null;
            var inMore = false;
            var tokenBeginOffset = _bufferPosition;
            var firstChar = 0;
            // The core tokenization loop
            while (matchedToken == null) {
                var codeUnitsRead = 0;
                var matchedPos = 0;
                int curChar;
                TokenType? matchedType = null;
                var reachedEnd = false;
                if (inMore) {
                    curChar = ReadChar();
                    if (curChar < 0) reachedEnd = true;
                }
                else {
                    tokenBeginOffset = _bufferPosition;
                    firstChar = curChar = ReadChar();
                    if (curChar < 0) {
                        matchedType = TokenType.EOF;
                        reachedEnd = true;
                    }
                }
                NfaFunction[] functions = GetFunctionTable(_lexicalState);
                // the core NFA loop
                if (!reachedEnd) do {
                    // Holder for the new type (if any) matched on this iteration
                    TokenType? newType = null;
                    if (codeUnitsRead > 0) {
                        // What was _nextStates on the last iteration
                        // is now the _currentStates!
                        (_currentStates, _nextStates) = (_nextStates, _currentStates);
                        var c = ReadChar();
                        if (c >= 0) {
                            curChar = c;
                        }
                        else {
                            // reachedEnd = true;
                            break;
                        }
                    }
                    _nextStates.Clear();
                    if (codeUnitsRead == 0) {
                        TokenType? returnedType = functions[0](curChar, _nextStates, ActiveTokenTypes);
                        if (returnedType != null) {
                            newType = returnedType;
                        }
                    }
                    else {
                        int nextActive = _currentStates.NextSetBit(0);
                        while (nextActive != -1) {
                            TokenType? returnedType = functions[nextActive](curChar, _nextStates, ActiveTokenTypes);
                            if ((returnedType != null) && ((newType == null) || ((int) returnedType.Value < (int) newType.Value))) {
                                newType = returnedType;
                            }
                            nextActive = _currentStates.NextSetBit(nextActive + 1);
                        }
                    }
                    ++codeUnitsRead;
                    if (curChar >= 0xFFFF) {
                        ++codeUnitsRead;
                    }
                    if (newType != null) {
                        matchedType = newType;
                        inMore = moreTokens.Contains(matchedType.Value);
                        matchedPos = codeUnitsRead;
                    }
                } while (!_nextStates.IsEmpty);
                if (matchedType == null) {
                    _bufferPosition = tokenBeginOffset + 1;
                    if (firstChar > 0xFFFF) {
                        ++_bufferPosition;
                    }
                    return new InvalidToken(this, tokenBeginOffset, _bufferPosition);
                }
                _bufferPosition -= (codeUnitsRead - matchedPos);
                if (skippedTokens.Contains((TokenType) matchedType)) {
                    for (int i = tokenBeginOffset; i < _bufferPosition; i++) {
                        if (_tokenLocationTable[i] != Ignored) {
                            _tokenLocationTable[i] = Skipped;
                        }
                    }
                }
                if (regularTokens.Contains((TokenType) matchedType) || unparsedTokens.Contains((TokenType) matchedType)) {
                    matchedToken = Token.NewToken((TokenType) matchedType, 
                                                  this, 
                                                  tokenBeginOffset,
                                                  _bufferPosition);
                    matchedToken.IsUnparsed = !regularTokens.Contains((TokenType) matchedType);
                    matchedToken = tokenHookΣPythonLexer_javaccΣ32Σ18(matchedToken);
                }
            }
            return matchedToken;
        }

        // Reset the token source input
        // to just after the Token passed in.
        internal void Reset(Token t, LexicalState? state = null) {
            ResetTokenHookΣPythonLexer_javaccΣ85Σ17(t);
            GoTo(t.EndOffset);
            UncacheTokens(t);
            if (state != null) {
                SwitchTo(state.Value);
            }
        }


        private string MungeContent(string content, int tabsToSpaces, bool preserveLines,
                      bool unicodeEscape, bool ensureFinalEol)
        {
            StringBuilder buf;

            if (tabsToSpaces <= 0 && preserveLines && !unicodeEscape) {
                if (!ensureFinalEol) return _content;
                if (content.Length == 0) {
                    content = "\n";
                }
                else {
                    int lastChar = _content[^1];
                    if (lastChar == '\n' || lastChar == '\r') return content;
                    buf = new StringBuilder(content);
                    buf.Append('\n');
                    content = buf.ToString();
                }
                return content;
            }
            buf = new StringBuilder();
            // This is just to handle tabs to spaces. If you don't have that setting set, it
            // is really unused.
            var col = 0;
            var justSawUnicodeEscape = false;
            // There might be some better way of doing this ...
            var bytes = Encoding.UTF32.GetBytes(content);
            var codePoints = new int[bytes.Length / 4];
            Buffer.BlockCopy(bytes, 0, codePoints, 0, bytes.Length);
            for (var index = 0; index < codePoints.Length; )
            {
                var ch = codePoints[index++];
                switch (ch)
                {
                    case '\\' when unicodeEscape && index < codePoints.Length:
                    {
                        ch = codePoints[index++];
                        if (ch != 'u') {
                            justSawUnicodeEscape = false;
                            buf.Append('\\');
                            buf.Append((char) ch);
                            if (ch == '\n')
                                col = 0;
                            else
                                col += 2;
                        } else {
                            while (codePoints[index] == 'u') {
                                index++;
                                // col++;
                            }
                            var hexBuf = new StringBuilder(4);
                            for (var i = 0; i < 4; i++) hexBuf.Append((char) codePoints[index++]);
                            var current = (char) Convert.ToInt32(hexBuf.ToString(), 16);
                            var last = buf.Length > 0 ? buf[^1] : (char) 0;
                            if (justSawUnicodeEscape && char.IsSurrogatePair(last, current)) {
                                buf.Length -= 1;
                                --col;
                                buf.Append(char.ConvertToUtf32(last, current));
                                justSawUnicodeEscape = false;
                            } else {
                                buf.Append(current);
                                justSawUnicodeEscape = true;
                            }
                            // col +=6;
                            ++col;
                            // We're not going to be trying to track line/column information relative to the original content
                            // with tabs or unicode escape, so we just increment 1, not 6
                        }

                        break;
                    }
                    case '\r' when !preserveLines:
                    {
                        justSawUnicodeEscape = false;
                        buf.Append('\n');
                        if (index < codePoints.Length) {
                            ch = codePoints[index++];
                            if (ch != '\n') {
                                buf.Append((char) ch);
                                ++col;
                            }
                            else
                            {
                                col = 0;
                            }
                        }
                        break;
                    }
                    case '\t' when tabsToSpaces > 0:
                    {
                        justSawUnicodeEscape = false;
                        int spacesToAdd = tabsToSpaces - col % tabsToSpaces;
                        for (int i = 0; i < spacesToAdd; i++) {
                            buf.Append(' ');
                            col++;
                        }

                        break;
                    }
                    default:
                    {
                        justSawUnicodeEscape = false;
                        buf.Append(char.ConvertFromUtf32(ch));
                        if (ch == '\n') {
                            col = 0;
                        } else
                            col++;

                        break;
                    }
                }
            }

            if (!ensureFinalEol) return buf.ToString();
            if (buf.Length == 0) {
                return "\n";
            }
            var lc = buf[^1];
            if (lc != '\n' && lc!='\r') buf.Append('\n');
            return buf.ToString();
        }

        /*
         * The offset of the end of the given line. This is in code units.
        private int GetLineEndOffset(int lineNumber) {
            int realLineNumber = lineNumber - startingLine;
            if (realLineNumber < 0) {
                return 0;
            }
            if (realLineNumber >= _lineOffsets.Length) {
                return _contentLength;
            }
            if (realLineNumber == _lineOffsets.Length - 1) {
                return _contentLength - 1;
            }
            return _lineOffsets[realLineNumber + 1] - 1;
        }
        */

        private void GoTo(int offset) {
            while (_tokenLocationTable[offset] == Ignored && offset < _contentLength) {
                ++offset;
            }
            _bufferPosition = offset;
        }

        /**
        * return the line length in code _units_
        private int GetLineLength(int lineNumber) {
            int startOffset = GetLineStartOffset(lineNumber);
            int endOffset = GetLineEndOffset(lineNumber);
            return 1 + endOffset - startOffset;
        }
        */ 

        /**
        * The number of supplementary unicode characters in the specified 
        * offset range. The range is expressed in code units
        */
        private int NumSupplementaryCharactersInRange(int start, int end) {
            int result = 0;
            while (start < end - 1) {
                if (char.IsHighSurrogate(_content[start++])) {
                    if (char.IsLowSurrogate(_content[start])) {
                        start++;
                        result++;
                    }
                }
            }
            return result;
        }

        /*
         * The offset of the start of the given line. This is in code units
        private int GetLineStartOffset(int lineNumber) {
            int realLineNumber = lineNumber - startingLine;
            if (realLineNumber <= 0) {
                return 0;
            }
            if (realLineNumber >= _lineOffsets.Length) {
                return _contentLength;
            }
            return _lineOffsets[realLineNumber];
        }
        */

        private int ReadChar() {
            while (_tokenLocationTable[_bufferPosition] == Ignored && _bufferPosition < _contentLength) {
                ++_bufferPosition;
            }
            if (_bufferPosition >= _contentLength) {
                return -1;
            }
            char ch = _content[_bufferPosition++];
            if (char.IsHighSurrogate(ch) && _bufferPosition < _contentLength) {
                char nextChar = _content[_bufferPosition];
                if (char.IsLowSurrogate(nextChar)) {
                    ++_bufferPosition;
                    return char.ConvertToUtf32(ch, nextChar);
                }
            }
            return ch;
        }

        /**
        * This is used in conjunction with having a preprocessor.
        * We set which lines are actually parsed lines and the 
        * unset ones are ignored. 
        * @param parsedLines a #java.util.BitSet that holds which lines
        * are parsed (i.e. not ignored)
        */
        public void SetParsedLines(BitSet parsedLines) {
            for (int i = 0; i < _lineOffsets.Length; i++) {
                if (!parsedLines[i + 1]) {
                    int lineOffset = _lineOffsets[i];
                    int nextLineOffset = i < _lineOffsets.Length -1 ? _lineOffsets[i+1] : _contentLength;
                    for (int offset = lineOffset; offset < nextLineOffset; offset++) {
                        _tokenLocationTable[offset] = Ignored;
                    }
                }
            }
        }

        /**
        * @return the line number from the absolute offset passed in as a parameter
        */
        internal int GetLineFromOffset(int pos) {
            if (pos >= _contentLength) {
                if (_content[_contentLength - 1] == '\n') {
                    return startingLine + _lineOffsets.Length;
                }
                return startingLine + _lineOffsets.Length - 1;
            }
            int bsearchResult = System.Array.BinarySearch(_lineOffsets, pos);
            if (bsearchResult >= 0) {
                return startingLine + bsearchResult;
            }
            return startingLine -(bsearchResult + 2);
        }

        internal int GetCodePointColumnFromOffset(int pos) {
            if (pos >= _contentLength) return 1;
            if (pos == 0) return startingColumn;
            if (char.IsLowSurrogate(_content[pos])) --pos;
            int line = GetLineFromOffset(pos) - startingLine;
            int lineStart = _lineOffsets[line];
            int numSupps = NumSupplementaryCharactersInRange(lineStart, pos);
            int startColumnAdjustment = line > 0 ? 1 : startingColumn;
            return startColumnAdjustment + pos - _lineOffsets[line] - numSupps;
        }
        
        /**
        * @return the text between startOffset (inclusive)
        * and endOffset(exclusive)
        */
        internal string GetText(int startOffset, int endOffset) {
            StringBuilder buf = new StringBuilder();
            for (int offset = startOffset; offset < endOffset; offset++) {
                if (_tokenLocationTable[offset] != Ignored) {
                    buf.Append(_content[offset]);
                }
            }
            return buf.ToString();
        }

        internal void CacheToken(Token tok) {
            if (tok.isInserted) {
                Token next = tok.NextCachedToken;
                if (next != null) CacheToken(next);
                return;
            }
            int offset = tok.BeginOffset;
            _tokenOffsets.Set(offset);
            _tokenLocationTable[offset] = tok;
        }

        void UncacheTokens(Token lastToken) {
            int endOffset = lastToken.EndOffset;
            if (endOffset < _tokenOffsets.Length) {
                _tokenOffsets.Clear(lastToken.EndOffset, _tokenOffsets.Length);
            }
            lastToken.UnsetAppendedToken();
        }

        internal Token NextCachedToken(int offset) {
            int nextOffset = _tokenOffsets.NextSetBit(offset);
            return nextOffset == -1 ? null : _tokenLocationTable[nextOffset];
        } 

        internal Token PreviousCachedToken(int offset) {
            int prevOffset = _tokenOffsets.PreviousSetBit(offset - 1);
            return prevOffset == -1 ? null : _tokenLocationTable[prevOffset];
        }

        private static NfaFunction[] GetFunctionTable(LexicalState lexicalState) {
            // We only have one lexical state in this case, so we return that!
            return nfaFunctions;
        }
        
        private Token danglingIndentation;
        private int bracketNesting, parenthesesNesting, braceNesting;
        private ListAdapter<int> indentationStack = InitIndentationStack();


        private static ListAdapter<int> InitIndentationStack() {
            ListAdapter<int> result = new ListAdapter<int>();
            result.Add(1);
            return result;
        }

        private Token tokenHookΣPythonLexer_javaccΣ32Σ18(Token tok) {
            bool lineJoiningOn = ((bracketNesting > 0) || (parenthesesNesting > 0)) || (braceNesting > 0);
            TokenType type = tok.Type;
            var _tv_1 = type;
            switch (_tv_1) {
            case TokenType.LBRACE:
                braceNesting += 1;
                break;
            case TokenType.RBRACE:
                braceNesting -= 1;
                break;
            case TokenType.LPAREN:
                parenthesesNesting += 1;
                break;
            case TokenType.RPAREN:
                parenthesesNesting -= 1;
                break;
            case TokenType.LBRACKET:
                bracketNesting += 1;
                break;
            case TokenType.RBRACKET:
                bracketNesting -= 1;
                break;
            case TokenType.NEWLINE:
                if (lineJoiningOn || tok.StartsLine()) {
                    tok.IsUnparsed = true;
                }
                return tok;
            }
            if (danglingIndentation != null) {
                tok.PreInsert(danglingIndentation);
            }
            if ((lineJoiningOn || tok.IsUnparsed) || ((danglingIndentation == null) && (!tok.StartsLine()))) {
                return tok;
            }
            danglingIndentation = null;
            int beginColumn = tok.BeginColumn;
            int indentation = indentationStack[indentationStack.Count - 1];
            if (beginColumn > indentation) {
                indentationStack.Add(beginColumn);
                return IndentToken.MakeIndentToken(tok, this, indentationStack);
            }
            if (beginColumn < indentation) {
                return HandleDedent(tok, beginColumn);
            }
            return tok;
        }

        private Token HandleDedent(Token tok, int offset) {
            int dedentIndex = indentationStack.IndexOf(offset);
            if (dedentIndex < 0) {
                Token invalidDedent = new InvalidToken(this, 0, 0);
                invalidDedent.Image = "Invalid Dedent";
                tok.PreInsert(invalidDedent);
                return invalidDedent;
            }
            Token firstDedent = null;
            int i = indentationStack.Count - 1;
            while (i > dedentIndex) {
                int dedentAmount = indentationStack[i] - indentationStack[i - 1];
                indentationStack.Remove(i);
                Token dedent = DedentToken.MakeDedentToken(tok, this, indentationStack, dedentAmount);
                if (firstDedent == null) {
                    firstDedent = dedent;
                }
                i -= 1;
            }
            return firstDedent;
        }

        private void ResetTokenHookΣPythonLexer_javaccΣ85Σ17(Token tok) {
            braceNesting = bracketNesting = parenthesesNesting = 0;
            if ((tok.Type == TokenType.INDENT) || (tok.Type == TokenType.DEDENT)) {
                danglingIndentation = tok;
                indentationStack = tok.GetIndents();
                return;
            }
            Iterator<Token> toks = tok.PrecedingTokens();
            while (toks.HasNext()) {
                Token previous = toks.Next();
                TokenType prevType = previous.Type;
                var _tv_2 = prevType;
                switch (_tv_2) {
                case TokenType.LBRACE:
                    braceNesting += 1;
                    break;
                case TokenType.RBRACE:
                    braceNesting -= 1;
                    break;
                case TokenType.LPAREN:
                    parenthesesNesting += 1;
                    break;
                case TokenType.RPAREN:
                    parenthesesNesting -= 1;
                    break;
                case TokenType.LBRACKET:
                    bracketNesting += 1;
                    break;
                case TokenType.RBRACKET:
                    bracketNesting -= 1;
                    break;
                case TokenType.INDENT:
                case TokenType.DEDENT:
                    indentationStack = previous.GetIndents();
                    return;
                }
            }
        }


    }
}
